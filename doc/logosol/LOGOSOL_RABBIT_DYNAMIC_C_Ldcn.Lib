#nodebug
#memmap xmem

/* START LIBRARY DESCRIPTION *********************************************
LDCN.LIB version 1.52N
END DESCRIPTION **********************************************************/

/* START FUNCTION DESCRIPTION ********************************************
ldcnhelp               <Ldcn.lib>
SYNTAX: ldcnhelp

DESCRIPTION:    LDCN  Library  Table  Contents

         GlobalDefinitions       Rabbit     SerialIO

         LdcNetworkConstants     LdcNetworkFunctions

         ServoModuleConstants    ServoModuleFunctions

                       CoordinatedMotion

         IONodeConstants         IONodeFunctions

         StepperConstants        StepperFunctions

END DESCRIPTION **********************************************************/


// ------------------------------------------------------------------------
// G L O B A L S ----------------------------------------------------------
// ------------------------------------------------------------------------


/* START FUNCTION DESCRIPTION ********************************************
GlobalDefinitions               <Ldcn.lib>

#define false 0
#define true !false
#define INVALID_HANDLE_VALUE (int) 0

typedef int bool;
typedef int handle;
END DESCRIPTION **********************************************************/

/*** BeginHeader false, true, INVALID_HANDLE_VALUE, bool, handle */
#ifndef false
  #define false 0
#endif

#ifndef true
  #define true !false
#endif

#define INVALID_HANDLE_VALUE (int) 0

typedef int bool;
typedef int handle;
/*** EndHeader */


// ------------------------------------------------------------------------
// R A B B I T ------------------------------------------------------------
// ------------------------------------------------------------------------


/* START FUNCTION DESCRIPTION ********************************************
Rabbit                 <Ldcn.lib>

#define AINBUFSIZE  63
#define AOUTBUFSIZE 63
#define BINBUFSIZE  63
#define BOUTBUFSIZE 63
#define CINBUFSIZE  63
#define COUTBUFSIZE 63
#define DINBUFSIZE  63
#define DOUTBUFSIZE 63

int  RabbitVersion;

int  ReadPortBit(char port, byte bitN);
int  ReadPortByte(char port);
int  WritePortBit(char port, int value, byte bitN);
int  WritePortByte(char port, int value);
void LightIntensity(byte i);
void delay(unsigned int n);
END DESCRIPTION **********************************************************/

/*** BeginHeader RabbitVersion, PDstatus */

#define AINBUFSIZE  63
#define AOUTBUFSIZE 63
#define BINBUFSIZE  63
#define BOUTBUFSIZE 63
#define CINBUFSIZE  63
#define COUTBUFSIZE 63
#define DINBUFSIZE  63
#define DOUTBUFSIZE 63
#define PD_OPEN    0x10
#define PD_232MODE 0x00
#define PD_485MODE 0x01

byte PDstatus;

byte i_980[5];
byte o_980[5];

byte i_981[5];
byte o_981[5];

byte i_984[5];
byte o_984[5];

//-------------------------------------------

int  RabbitVersion;
/*** EndHeader */

/* **********************************************************************************
VERSION | 980                                 | 981                                 |
========|=====================================|=====================================|
PORT  A | Outputs Not used Set to 0           | Inputs                              |
      B |                                     |                                     |
      C | Serial ports                        | Serial ports                        |
      D | 0..3 Input SW                       | 0..3 Inputs SW                      |
        | 4    Output - Not used              | 4    Output - Not used,    Set to 0 |
        | 5    Output -              Set to 0 | 5    Output -              Set to 0 |
        | 6    Output - Not used,    Set to 0 | 6    Output - Not used,    Set to 0 |
        | 7    LED Output OpenDrain, Set to 1 | 7    LED Output OpenDrain, Set to 1 |
      E | Outputs     - Not used,    Set to 0 | Outputs                             |
********************************************************************************** */

//-------------------------------------------
// Internal Use Only

/*** BeginHeader InitRabbit */
     int InitRabbit();
/*** EndHeader */

int InitRabbit() {
int pb;
  segchain _GLOBAL_INIT {

    i_980[0] = 0;     i_980[1] = 0;  i_980[2] = 0;  i_980[3] = 0x0f;  i_980[4] = 4;
    o_980[0] = 0;     o_980[1] = 0;  o_980[2] = 0;  o_980[3] = 0xA0;  o_980[4] = 0;
    i_981[0] = 0xff;  i_981[1] = 0;  i_981[2] = 0;  i_981[3] = 0x0f;  i_981[4] = 0;
    o_981[0] = 0;     o_981[1] = 0;  o_981[2] = 0;  o_981[3] = 0xA0;  o_981[4] = 0xff;
    i_984[0] = 0;     i_984[1] = 0;  i_984[2] = 0;  i_984[3] = 0x0f;  i_984[4] = 0;
    o_984[0] = 0;     o_984[1] = 0;  o_984[2] = 0;  o_984[3] = 0x60;  o_984[4] = 0;

    pb = RdPortI( PBDR);
    switch (pb) {
      case 0x1f: RabbitVersion = 980;
        WrPortI(PDDDR, &PDDDRShadow, 0xf0); // setup parallel port D - bits 0..3 - inputs, 4..7 - outputs
        WrPortI(PDDCR, &PDDCRShadow, 0x80); // setup port D bit 7 as open drain output
        WrPortI(SPCR,  &SPCRShadow,  0x84); // setup parallel port A as output
        WrPortI(PADR,  &PADRShadow,  0x00); // set port A to 0
        WrPortI(PEDDR, &PEDDRShadow, 0xff); // setup parallel port E as output
        WrPortI(PEDR,  &PEDRShadow,  0x00); // set port E to 0

        BitWrPortI(PDDR, &PDDRShadow, 0, 5); // set port D, bit 5 to 0
        BitWrPortI(PDDR, &PDDRShadow, 0, 6); // set port D, bit 6 to 0
        BitWrPortI(PDDR, &PDDRShadow, 1, 7); // set port D, bit 7 to 1

        break;
      case 0x2f: RabbitVersion = 981;
        WrPortI(SPCR,  &SPCRShadow,  0x80); // setup parallel port A as input
        WrPortI(PDDDR, &PDDDRShadow, 0xf0); // setup parallel port D - bits 0..3 - inputs, 4..7 - outputs
        WrPortI(PDDCR, &PDDCRShadow, 0x80); // setup port D bit 7 as open drain output
        WrPortI(PEDDR, &PEDDRShadow, 0xff); // setup parallel port E as output

        BitWrPortI(PDDR, &PDDRShadow, 0, 4); // set port D, bit 4 to 0
        BitWrPortI(PDDR, &PDDRShadow, 0, 5); // set port D, bit 5 to 0
        BitWrPortI(PDDR, &PDDRShadow, 0, 6); // set port D, bit 6 to 0
        BitWrPortI(PDDR, &PDDRShadow, 1, 7); // set port D, bit 7 to 1

      break;
      case 0x17: RabbitVersion = 984;
        WrPortI(SPCR,  &SPCRShadow,  0x80); // setup parallel port A as input
        WrPortI(PDDDR, &PDDDRShadow, 0x60); // setup parallel port D - bits 0..3,4,7 - inputs, 5,6 - outputs
        WrPortI(PEDDR, &PEDDRShadow, 0xc2); // setup parallel port E - bits 0,2..5   - inputs, 1,6,7 - outputs

        WrPortI(PDDR, &PDDRShadow, 0x40);
        WrPortI(PEDR, &PEDRShadow, 0xc2);

        break;
      default: RabbitVersion = 0;
    } // switch

    PDstatus = PD_232MODE;

  } // _GLOBAL_INIT
  return 1;
} // InitRabbit
//---------------------------------------------------------------------------

/*** BeginHeader IsInput */
     int IsInput(char * port, int bitN);
/*** EndHeader */

int IsInput(char * port, int bitN)  {
char p;

  InitRabbit();

  if ((*port >= 'a') && (*port <= 'e')) (*port) -= 32; // uppercase
  if ((*port <  'A') || (*port >  'E')) return 0;
  p = *port;

  p -= 65;                        // A->0, B->1, C->2, ...
  if ((bitN >= 0) && (bitN <= 7)) // for particular bit
     switch (RabbitVersion) {
       case 980: return (i_980[p] & (1 << bitN));
       case 981: return (i_981[p] & (1 << bitN));
       case 984: return (i_984[p] & (1 << bitN));
       default: return 0;
     } else                       // if there is any input in that port
     switch (RabbitVersion) {
       case 980: return (i_980[p]);
       case 981: return (i_981[p]);
       case 984: return (i_984[p]);
       default: return 0;
     }
}
//-------------------------------------------

/*** BeginHeader IsOutput */
     int IsOutput(char * port, int *value, int bitN);
/*** EndHeader */

int IsOutput(char * port, int *value, int bitN)  {
char p;

  InitRabbit();

  if ((*port >= 'a') && (*port <= 'e')) (*port) -= 32; // uppercase
  if ((*port <  'A') || (*port >  'E')) return 0;
  p = *port;

  p -= 65;                        // A->0, B->1, C->2, ...
  if ((bitN >= 0) && (bitN <= 7)) // for particular bit
     switch (RabbitVersion) {
       case 980: return (o_980[p] & (1 << bitN));
       case 981: return (o_981[p] & (1 << bitN));
       case 984: return (o_984[p] & (1 << bitN));
       default: return 0;
     } else
     switch (RabbitVersion) {     // if there is any input in that port
       case 980: (*value) &= o_980[p]; return (o_980[p]);  // if for any version there are default bits set to 1 ???
       case 981: (*value) &= o_981[p]; return (o_981[p]);
       case 984: (*value) &= o_984[p]; return (o_984[p]);
       default: return 0;
     }
}
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
ReadPortBit                 <Ldcn.lib>

SYNTAX: int ReadPortBit (char port, int bitN);

PARAMETER1: <port> - port name.
PARAMETER2: <bitN> - bit to read (0-7)

KEYWORDS: Rabbit

RETURN VALUE: Returns 1 or 0 matching the value of the bit read from <port>
              or -1 if <port> is an invalid port name or bitN is an invalid bit number.
END DESCRIPTION **********************************************************/

/*** BeginHeader ReadPortBit */
     int ReadPortBit(char port, byte bitN);
/*** EndHeader */

int ReadPortBit(char port, byte bitN) {
// Return: -1 = error, else - 0 or 1;

int p;

  if (!IsInput(&port, bitN) || (bitN < 0) || (bitN > 7)) return -1;
  switch (port) {
    case 'A': p = PADR; break;
    case 'B': p = PBDR; break;
    case 'C': p = PCDR; break;
    case 'D': p = PDDR; break;
    case 'E': p = PEDR; break;
  }
  return BitRdPortI(p, bitN);
}
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
ReadPortByte                 <Ldcn.lib>

SYNTAX: int ReadPortByte (char port);

PARAMETER1: <port> - port name.

KEYWORDS: Rabbit

RETURN VALUE: Returns the read from <port> byte or -1 on error.
END DESCRIPTION **********************************************************/

/*** BeginHeader ReadPortByte */
     int ReadPortByte(char port);
/*** EndHeader */

int ReadPortByte(char port) {
// Return: -1 = error, else port value;

int p;

  if (!IsInput(&port, -1)) return -1;
  switch (port) {
    case 'A': p = PADR; break;
    case 'B': p = PBDR; break;
    case 'C': p = PCDR; break;
    case 'D': p = PDDR; break;
    case 'E': p = PEDR; break;
  }
  p = RdPortI(p);

  switch (RabbitVersion) {
// if for any version there are default bits set to 1 ???
    case 980: p &= i_980[port - 65]; break;
    case 981: p &= i_981[port - 65]; break;
    case 984: p &= i_984[port - 65]; break;
    default: return 0;
  }
  return p;
}
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
WritePortBit                 <Ldcn.lib>

SYNTAX: int WritePortBit (char port, int value, int bitN);

PARAMETER1: <port>  - port name.
PARAMETER2: <value> - value to be written (0 or 1)
PARAMETER3: <bitN>  - bit number (0-7)

KEYWORDS: Rabbit

DESCRIPTION: Write <value> into bit <bitN> in <port>

RETURN VALUE: true on success, false on failure
END DESCRIPTION **********************************************************/

/*** BeginHeader WritePortBit */
     int WritePortBit(char port, int value, byte bitN);
/*** EndHeader */

int WritePortBit(char port, int value, byte bitN) {
// Return: 0 = error, 1 = OK;

  if ((value < 0) || (value > 1) || (bitN < 0) || (bitN > 7)) return 0;
  if (!IsOutput(&port, &value, bitN)) return 0;

  switch (port) {
    case 'A': BitWrPortI(PADR, &PADRShadow, value, bitN); break;
    case 'B': BitWrPortI(PBDR, &PBDRShadow, value, bitN); break;
    case 'C': BitWrPortI(PCDR, &PCDRShadow, value, bitN); break;
    case 'D': BitWrPortI(PDDR, &PDDRShadow, value, bitN); break;
    case 'E': BitWrPortI(PEDR, &PEDRShadow, value, bitN); break;
  }
  return 1;
}
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
WritePortByte                 <Ldcn.lib>

SYNTAX: int WritePortByte (char port, int value);

PARAMETER1: <port>  - port name.
PARAMETER2: <value> - value to be written to the <port>

KEYWORDS: Rabbit

DESCRIPTION: Write <value> into <port>

RETURN VALUE: true on success, false on failure
END DESCRIPTION **********************************************************/

/*** BeginHeader WritePortByte */
     int WritePortByte(char port, int value);
/*** EndHeader */

int WritePortByte(char port, int value) {
// Return: 0 = error, 1 = OK;

  if (!IsOutput(&port, &value, -1)) return 0;

  switch (port) {
    case 'A': WrPortI(PADR, &PADRShadow, value); break;
    case 'B': WrPortI(PBDR, &PBDRShadow, value); break;
    case 'C': WrPortI(PCDR, &PCDRShadow, value); break;
    case 'D': WrPortI(PDDR, &PDDRShadow, value); break;
    case 'E': WrPortI(PEDR, &PEDRShadow, value); break;
  }
  return 1;
}
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
LightIntensity                  <Ldcn.lib>

SYNTAX: void LightIntensity (byte i);

PARAMETER1:  <i> -  0 - NONE
                    2 - HIGH
                    other - LOW (BY DEFAULT)
KEYWORDS: Rabbit

DESCRIPTION: Set the light intensity of the Rabbit's LED.
             Only for RabbitVersion != 984

RETURN VALUE: NONE
END DESCRIPTION **********************************************************/

/*** BeginHeader LightIntensity */
     void LightIntensity(byte i);
/*** EndHeader */

void LightIntensity(byte i) {
// change the light intensity

   InitRabbit();

   if (RabbitVersion == 984) return;

   switch (i) {
   case 0:    // NONE
        WrPortI(PDDCR, &PDDCRShadow, 0x00);
        BitWrPortI( PDDR, &PDDRShadow, 1, 7);
        break;
   case 2:    // HIGH
        WrPortI(PDDCR, &PDDCRShadow, 0x80);
        BitWrPortI( PDDR, &PDDRShadow, 0, 7);
        break;
   default:   // LOW
        WrPortI(PDDCR, &PDDCRShadow, 0x80);    // open drain
        BitWrPortI( PDDR, &PDDRShadow, 1, 7);
        break;
   }
}
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
delay             <Ldcn.lib>

SYNTAX: void delay (unsigned int n);

PARAMETER1: <n> - number of milliseconds

KEYWORDS: Rabbit

DESCRIPTION: Delay <n> milliseconds

RETURN VALUE: NONE
END DESCRIPTION **********************************************************/

// Delay function in milliseconds

/*** BeginHeader delay */
     void delay(unsigned int n);
/*** EndHeader */

void delay(unsigned int n) {
  unsigned long start_time;
  start_time = MS_TIMER;
  while (MS_TIMER - start_time < n) hitwd();
}


// ------------------------------------------------------------------------
// S E R I A L  I O  ------------------------------------------------------
// ------------------------------------------------------------------------


/* START FUNCTION DESCRIPTION ********************************************
SerialIO                    <Ldcn.lib>

handle SioOpen(int port, long baudrate);
bool SioChangeBaud( handle ComPort, long baudrate);
bool SioPutChars( handle ComPort, char *stuff, int n);
int  SioGetChars( handle ComPort, char *stuff, int n);
int  SioTest( handle ComPort);
bool SioClrInbuf( handle ComPort);
bool SioClose( handle ComPort);
bool SioPDmode(int mode);
END DESCRIPTION **********************************************************/


/* START FUNCTION DESCRIPTION ********************************************
SioOpen                    <Ldcn.lib>

SYNTAX: handle SioOpen (int port, long baudrate);

PARAMETER1: <port>     - valid COM port (1..4)
PARAMETER2: <baudrate> - Valid baud rates :
                         9600, 19200, 38400, 57600 and 115200
KEYWORDS: SerialIO

DESCRIPTION: Opens a COM port at the specified baud rate

RETURN VALUE: If the function succeeds the return value is an open
              handle to the specified COM port, if the function fails,
              the return value is INVALID_HANDLE_VALUE.
END DESCRIPTION **********************************************************/

// Opens a COM port, returns a handle to be used by other
// SIO operations.

/*** BeginHeader SioOpen */
     handle SioOpen(int port, long baudrate);
/*** EndHeader */

handle SioOpen(int port, long baudrate) {
  int res;

  InitRabbit();

  if (baudrate !=   9600)
  if (baudrate !=  19200)
  if (baudrate !=  38400)
  if (baudrate !=  57600)
  if (baudrate != 115200)
      baudrate  =  19200;

  switch (port) {
    case 1:  res = 1 * serAopen( baudrate); break;
    case 2:  res = 2 * serBopen( baudrate); break;
    case 3:  res = 3 * serCopen( baudrate); break;
    case 4:  res = 4 * serDopen( baudrate); if(res) PDstatus |= PD_OPEN; break;
    default: res = INVALID_HANDLE_VALUE;
  }
  return res;
}
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
SioClose                  <Ldcn.lib>

SYNTAX: bool SioClose (handle ComPort);

PARAMETER1: <ComPort> - valid COM port (1..4)

KEYWORDS: SerialIO

DESCRIPTION: Close a previously opened COM port

RETURN VALUE: true on success, false on failure
END DESCRIPTION **********************************************************/

// Close a previously opened COM port

/*** BeginHeader SioClose */
     bool SioClose( handle ComPort);
/*** EndHeader */

bool SioClose( handle ComPort) {
  switch (ComPort) {
    case 1:   serAclose(); return true;
    case 2:   serBclose(); return true;
    case 3:   serCclose(); return true;
    case 4:   serDclose(); PDstatus &= (~PD_OPEN);  return true;
    default:  return false;
  }
}
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
SioClrInbuf                  <Ldcn.lib>

SYNTAX: bool SioClrInbuf (handle ComPort);

PARAMETER1: <ComPort> - valid COM port (1..4)

KEYWORDS: SerialIO

DESCRIPTION: Clears all characters in ComPort's input buffer.

RETURN VALUE: true on success, false on failure
END DESCRIPTION **********************************************************/

/*** BeginHeader SioClrInbuf */
     bool SioClrInbuf( handle ComPort);
/*** EndHeader */

bool SioClrInbuf( handle ComPort) {
  switch (ComPort) {
    case 1:  while (serAgetc() != -1); break;
    case 2:  while (serBgetc() != -1); break;
    case 3:  while (serCgetc() != -1); break;
    case 4:  while (serDgetc() != -1); break;
    default:
  }
  return true;
}
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
SioChangeBaud                  <Ldcn.lib>

SYNTAX: bool SioChangeBaud (handle ComPort, long baudrate);

PARAMETER1: <port>     - valid COM port (1..4)
PARAMETER2: <baudrate> - Valid baud rates :
                         9600, 19200, 38400, 57600 and 115200
KEYWORDS: SerialIO

DESCRIPTION: Changes the baud rate of ComPort. The handle ComPort
             must have been created by SioOpen() function.

RETURN VALUE: Returns false on failure, true on success.
END DESCRIPTION **********************************************************/

// Change the baud rate to the specified values.  Valid rates are:
// 9600, 19200, 38400, 57600, 115200.  Returns TRUE on success.

/*** BeginHeader SioChangeBaud */
     bool SioChangeBaud( handle ComPort, long baudrate);
/*** EndHeader */

bool SioChangeBaud( handle ComPort, long baudrate) {
  if (baudrate !=   9600)
  if (baudrate !=  19200)
  if (baudrate !=  38400)
  if (baudrate !=  57600)
  if (baudrate != 115200)
      return false;

  switch (ComPort) {
    case 1:  serAclose;  return serAopen( baudrate);
    case 2:  serBclose;  return serBopen( baudrate);
    case 3:  serCclose;  return serCopen( baudrate);
    case 4:  serDclose;  return serDopen( baudrate);
    default: return false;
  }
}
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
SioPutChars                  <Ldcn.lib>

SYNTAX: bool SioPutChars (handle ComPort, char *stuff, int n);

PARAMETER1: <ComPort> - valid COM port (1..4)
PARAMETER2: <stuff>   - data buffer
PARAMETER3: <n>       - number of character to be written

KEYWORDS: SerialIO

DESCRIPTION: Writes out n characters to the COM port specified by the handle
             ComPort created by SioOpen(), returns only after chars have been
             sent. Stuff points to the buffer containing the data to be sent.

RETURN VALUE: Return 0 on failure, non-zero on success.
END DESCRIPTION **********************************************************/

/*** BeginHeader SioPutChars */
     bool SioPutChars( handle ComPort, char *stuff, int n);
/*** EndHeader */

bool SioPutChars( handle ComPort, char *stuff, int n) {
  int nums;

  switch (ComPort) {
    case 1: nums = serAwrite( stuff, n); break;
    case 2: nums = serBwrite( stuff, n); break;
    case 3: nums = serCwrite( stuff, n); break;
    case 4:
      nums = 0;
      if (PDstatus == (PD_OPEN | PD_485MODE)) {
       if (WritePortBit('D', 1, 5)) {
         nums = serDwrite( stuff, n);
         do {} while (RdPortI(0xF3) & 0x0C);     // read status register for D from address F3 (SBSR)
                                                 // while Transmiter Data buffer emty (bit 3) = 0 and
                                                 // Transmiter Busy (bit 2) = 0
         WritePortBit('D', 0, 5);
         SioClrInbuf(4);
       }
      } else nums = serDwrite( stuff, n);
      break;
    default: return false;
  }
  return nums == n;
}
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
SioTest                       <Ldcn.lib>

SYNTAX: int SioTest (handle ComPort);

PARAMETER1: <ComPort> - valid COM port (1..4)

KEYWORDS: SerialIO

RETURN VALUE: Returns the number of characters in the ComPort's input buffer
END DESCRIPTION **********************************************************/

/*** BeginHeader SioTest */
     int SioTest( handle ComPort);
/*** EndHeader */

int SioTest( handle ComPort) {
  int nums;

  switch (ComPort) {
    case 1:  nums = serArdUsed(); break;
    case 2:  nums = serBrdUsed(); break;
    case 3:  nums = serCrdUsed(); break;
    case 4:  nums = serDrdUsed(); break;
    default: nums = 0;
  }
  return nums;
}
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
SioGetChars                 <Ldcn.lib>

SYNTAX: int SioGetChars (handle ComPort, char *stuff, int n);

PARAMETER1: <ComPort> - valid COM port (1..4)
PARAMETER2: <stuff>   - data buffer
PARAMETER3: <n>       - number of character to read

KEYWORDS: SerialIO

DESCRIPTION: Read in <n> characters from the COM port specified by the handle ComPort,
             created by SioOpen() and puts them in the array pointed to by stuff.
             This function has a timeout value of approximately 100 milliseconds.

RETURN VALUE: Returns the number of characters actually read.
END DESCRIPTION **********************************************************/

/*** BeginHeader SioGetChars */
#define TIME_OUT 100
     int SioGetChars( handle ComPort, char *stuff, int n);
/*** EndHeader */

int SioGetChars( handle ComPort, char *stuff, int n) {
int nums;
unsigned long t0;

  t0 = MS_TIMER;

  while ((SioTest(ComPort) == 0) && ((MS_TIMER - t0) < TIME_OUT)) {}

  switch (ComPort) {
    case 1:  nums = serAread( stuff, n, TIME_OUT); break;
    case 2:  nums = serBread( stuff, n, TIME_OUT); break;
    case 3:  nums = serCread( stuff, n, TIME_OUT); break;
    case 4:  nums = serDread( stuff, n, TIME_OUT); break;
    default: nums = 0;
  }
  return nums;
}
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
SioPDmode                  <Ldcn.lib>

SYNTAX: bool SioPDmode (int mode);

PARAMETER1: <mode> -  New mode status

KEYWORDS: SerialIO

DESCRIPTION: Set PDstatus in <mode> if PD not open.

RETURN VALUE: false if PD is already open, else - true
END DESCRIPTION **********************************************************/

/*** BeginHeader SioPDmode */
     bool SioPDmode(int mode);
/*** EndHeader */

bool SioPDmode(int mode) {
  if (PDstatus & PD_OPEN) return false;
  if (mode & PD_485MODE) {
     if (RabbitVersion == 984) WritePortBit('D', 0, 6);
     PDstatus |= PD_485MODE;
  }
  else {
     if (RabbitVersion == 984) WritePortBit('D', 1, 6);
     PDstatus &= (~PD_485MODE);
  }
}


//---------------------------------------------------------------------------
// S E R V O   M O D U L E  C O N S T A N T S -------------------------------
//---------------------------------------------------------------------------


/* START FUNCTION DESCRIPTION *********************************************
ServoModuleConstants             <Ldcn.lib>

-- Servo Module Command set:
#define RESET_POS         0x00  -- Reset encoder counter to 0 (0 bytes)
#define SET_ADDR          0x01  -- Set address and group address (2 bytes)
#define DEF_STAT          0x02  -- Define status items to return (1 byte)
#define READ_STAT         0x03  -- Read value of current status items
#define LOAD_TRAJ         0x04  -- Load trajectory date (1 - 14 bytes)
#define START_MOVE        0x05  -- Start pre-loaded trajectory (0 bytes)
#define SET_GAIN          0x06  -- Set servo gain and control parameters (13 or 14)
#define STOP_MOTOR        0x07  -- Stop motor (1 byte)
#define IO_CTRL           0x08  -- Define bit directions and set output (1 byte)
#define SET_HOMING        0x09  -- Define homing mode (1 byte)
#define SET_BAUD          0x0A  -- Set the baud rate (1 byte)
#define CLEAR_BITS        0x0B  -- Save current pos. in home pos. register (0 bytes)
#define SAVE_AS_HOME      0x0C  -- Store the input bytes and timer val (0 bytes)
#define EEPROM_CTRL       0x0D  -- Store or retrieve values from EEPROM
#define ADD_PATHPOINT     0x0D  -- Adds path popint in path mode
#define NOP               0x0E  -- No operation - returns prev. defined status (0 bytes)
#define HARD_RESET        0x0F  -- RESET - no status is returned

-- Servo Module RESET_POS control byte bit definitions:
-- (if no control byte is used, reset is absolute)
#define REL_HOME          0x01  -- Reset position relative to current home position

-- Servo Module STATUSITEMS bit definitions:
#define SEND_POS          0x01  -- 4 bytes data
#define SEND_AD           0x02  -- 1 byte
#define SEND_VEL          0x04  -- 2 bytes
#define SEND_AUX          0x08  -- 1 byte
#define SEND_HOME         0x10  -- 4 bytes
#define SEND_ID           0x20  -- 2 bytes
#define SEND_PERROR       0x40  -- 2 bytes
#define SEND_INPORTS      0x80  -- 3 bytes
#define SEND_NPOINTS      0x80  -- 1 byte

-- Servo Module LOAD_TRAJ control byte bit definitions:
#define LOAD_POS          0x01  -- +4 bytes
#define LOAD_VEL          0x02  -- +4 bytes
#define LOAD_ACC          0x04  -- +4 bytes
#define LOAD_PWM          0x08  -- +1 byte
#define ENABLE_SERVO      0x10  -- 1 = servo mode, 0 = PWM mode
#define VEL_MODE          0x20  -- 1 = velocity mode, 0 = trap. position mode
#define REVERSE           0x40  -- 1 = command neg. PWM or vel, 0 = positive
#define MOVE_REL          0x40  -- 1 = relative move, 0 = absolute move; works in advanced mode
#define START_NOW         0x80  -- 1 = start now, 0 = wait for START_MOVE command

-- Servo Module STOP_MOTOR control byte bit definitions:
#define SRV_ENABLE_AMP    0x01  -- 1 = raise amp enable output, 0 = lower amp enable
#define MOTOR_OFF         0x02  -- set to turn motor off
#define STOP_ABRUPT       0x04  -- set to stop motor immediately
#define STOP_SMOOTH       0x08  -- set to decellerate motor smoothly
#define STOP_HERE         0x10  -- set to stop at position (4 add'l data bytes required)
#define ADV_MODE          0x20  -- Enables advanced mode

-- Servo Module IO_CTRL control byte bit definitions:
#define SET_OUT1          0x01  -- 1 = set limit 1 output, 0 = clear limit 1 output
#define SET_OUT2          0x02  -- 1 = set limit 2 output, 0 = clear limit 2 output
#define IO1_IN            0x04  -- 1 = limit 1 is an input, 0 = limit 1 is an output
#define IO2_IN            0x08  -- 1 = limit 2 is an input, 0 = limit 2 is an output
#define WR_OUT1           0x10  -- Write to output port 1
#define WR_OUT2           0x20  -- Write to output port 2
#define WR_OUT3           0x40  -- Write to output port 3
#define FAST_PATH         0x40  -- 0 = 30-60 Hz, 1 = 60-120 Hz
#define WR_OUT4           0x80  -- Write to output port 4

-- Servo Module SET_HOMING control byte bit definitions:
#define ON_LIMIT1         0x01  -- home on change in limit 1
#define ON_LIMIT2         0x02  -- home on change in limit 2
#define HOME_MOTOR_OFF    0x04  -- turn motor off when homed
#define ON_INDEX          0x08  -- home on change in index
#define HOME_STOP_ABRUPT  0x10  -- stop abruptly when homed
#define HOME_STOP_SMOOTH  0x20  -- stop smoothly when homed
#define ON_POS_ERR        0x40  -- home on excessive position error
#define ON_CUR_ERR        0x80  -- home on overcurrent error

-- Servo Module EEPROM_CTRL control byte bit definitions:
#define STORE_GAINS       0x01  -- Store servo gains
#define FETCH_GAINS       0x02  -- Retrieve stored gains
#define STORE_VA          0x04  -- Store velocity and acceleration
#define FETCH_VA          0x08  -- Retrieve stored velocity and acceleration
#define STORE_OUTPUTS     0x10  -- Store output port values
#define FETCH_OUTPUTS     0x20  -- Retrieve stored output port values
#define STORE_SI_BIT      0x40  -- Store "servo initialize" bit
#define INIT_SERVO        0x80  -- Initializes servo on power-up

-- Servo Module ADD_PATHPOINT frequency definitions
#define P_30HZ              30  --  30 hz path resolution
#define P_60HZ              60  --  60 hz path resolution
#define P_120HZ            120  -- 120 hz path resolution

-- Servo Module Status byte bit definitions:
#define MOVE_DONE         0x01  -- set when move done (trap. pos mode), when goal
                                -- vel. has been reached (vel mode) or when not servoing
#define CKSUM_ERROR       0x02  -- checksum error in received command
#define OVERCURRENT       0x04  -- set on overcurrent condition (sticky bit)
#define POWER_ON          0x08  -- set when motor power is on
#define POS_ERR           0x10  -- set on excess pos. error (sticky bit)
#define LIMIT1            0x20  -- value of limit 1 input
#define LIMIT2            0x40  -- value of limit 2 input
#define HOME_IN_PROG      0x80  -- set while searching for home, cleared when home found

-- Servo Module Auxilliary status byte bit definitions:
#define INDEX             0x01  -- value of the encoder index signal
#define POS_WRAP          0x02  -- set when 32 bit position counter wraps around
                                   (sticky bit)
#define SERVO_ON          0x04  -- set when position servo is operating
#define ACCEL_DONE        0x08  -- set when acceleration portion of a move is done
#define SLEW_DONE         0x10  -- set when slew portion of a move is done
#define SERVO_OVERRUN     0x20  -- set if servo takes longer than the specified
                                   servo period to execute
#define PATH_MODE         0x40  -- path mode is enabled
END DESCRIPTION ***********************************************************/

//---------------------------------------------------------------------------

/*** BeginHeader */
// Servo Module Command set:
#define RESET_POS         0x00  // Reset encoder counter to 0 (0 bytes)
#define SET_ADDR          0x01  // Set address and group address (2 bytes)
#define DEF_STAT          0x02  // Define status items to return (1 byte)
#define READ_STAT         0x03  // Read value of current status items
#define LOAD_TRAJ         0x04  // Load trajectory date (1 - 14 bytes)
#define START_MOVE        0x05  // Start pre-loaded trajectory (0 bytes)
#define SET_GAIN          0x06  // Set servo gain and control parameters (13 or 14)
#define STOP_MOTOR        0x07  // Stop motor (1 byte)
#define IO_CTRL           0x08  // Define bit directions and set output (1 byte)
#define SET_HOMING        0x09  // Define homing mode (1 byte)
#define SET_BAUD          0x0A  // Set the baud rate (1 byte)
#define CLEAR_BITS        0x0B  // Save current pos. in home pos. register (0 bytes)
#define SAVE_AS_HOME      0x0C  // Store the input bytes and timer val (0 bytes)
#define EEPROM_CTRL       0x0D  // Store or retrieve values from EEPROM
#define ADD_PATHPOINT     0x0D  // Adds path popint in path mode
#define NOP               0x0E  // No operation - returns prev. defined status (0 bytes)
#define HARD_RESET        0x0F  // RESET - no status is returned

// Servo Module RESET_POS control byte bit definitions:
// (if no control byte is used, reset is absolute)
#define REL_HOME          0x01  // Reset position relative to current home position

// Servo Module STATUSITEMS bit definitions:
#define SEND_POS          0x01  // 4 bytes data
#define SEND_AD           0x02  // 1 byte
#define SEND_VEL          0x04  // 2 bytes
#define SEND_AUX          0x08  // 1 byte
#define SEND_HOME         0x10  // 4 bytes
#define SEND_ID           0x20  // 2 bytes
#define SEND_PERROR       0x40  // 2 bytes
#define SEND_INPORTS      0x80  // 3 bytes
#define SEND_NPOINTS      0x80  // 1 byte

// Servo Module LOAD_TRAJ control byte bit definitions:
#define LOAD_POS          0x01  // +4 bytes
#define LOAD_VEL          0x02  // +4 bytes
#define LOAD_ACC          0x04  // +4 bytes
#define LOAD_PWM          0x08  // +1 byte
#define ENABLE_SERVO      0x10  // 1 = servo mode, 0 = PWM mode
#define VEL_MODE          0x20  // 1 = velocity mode, 0 = trap. position mode
#define REVERSE           0x40  // 1 = command neg. PWM or vel, 0 = positive
#define MOVE_REL          0x40  // 1 = relative move, 0 = absolute move; works in advanced mode
#define START_NOW         0x80  // 1 = start now, 0 = wait for START_MOVE command

// Servo Module STOP_MOTOR control byte bit definitions:
#define SRV_ENABLE_AMP    0x01  // 1 = raise amp enable output, 0 = lower amp enable
#define MOTOR_OFF         0x02  // set to turn motor off
#define STOP_ABRUPT       0x04  // set to stop motor immediately
#define STOP_SMOOTH       0x08  // set to decellerate motor smoothly
#define STOP_HERE         0x10  // set to stop at position (4 add'l data bytes required)
#define ADV_MODE          0x20  // Enables advanced mode

// Servo Module IO_CTRL control byte bit definitions:
#define SET_OUT1          0x01  // 1 = set limit 1 output, 0 = clear limit 1 output
#define SET_OUT2          0x02  // 1 = set limit 2 output, 0 = clear limit 2 output
#define IO1_IN            0x04  // 1 = limit 1 is an input, 0 = limit 1 is an output
#define IO2_IN            0x08  // 1 = limit 2 is an input, 0 = limit 2 is an output
#define WR_OUT1           0x10  // Write to output port 1
#define WR_OUT2           0x20  // Write to output port 2
#define WR_OUT3           0x40  // Write to output port 3
#define FAST_PATH         0x40  // 0 = 30/60 Hz, 1 = 60/120 Hz
#define WR_OUT4           0x80  // Write to output port 4

// Servo Module SET_HOMING control byte bit definitions:
#define ON_LIMIT1         0x01  // home on change in limit 1
#define ON_LIMIT2         0x02  // home on change in limit 2
#define HOME_MOTOR_OFF    0x04  // turn motor off when homed
#define ON_INDEX          0x08  // home on change in index
#define HOME_STOP_ABRUPT  0x10  // stop abruptly when homed
#define HOME_STOP_SMOOTH  0x20  // stop smoothly when homed
#define ON_POS_ERR        0x40  // home on excessive position error
#define ON_CUR_ERR        0x80  // home on overcurrent error

// Servo Module EEPROM_CTRL control byte bit definitions:
#define STORE_GAINS       0x01  // Store servo gains
#define FETCH_GAINS       0x02  // Retrieve stored gains
#define STORE_VA          0x04  // Store velocity and acceleration
#define FETCH_VA          0x08  // Retrieve stored velocity and acceleration
#define STORE_OUTPUTS     0x10  // Store output port values
#define FETCH_OUTPUTS     0x20  // Retrieve stored output port values
#define STORE_SI_BIT      0x40  // Store "servo initialize" bit
#define INIT_SERVO        0x80  // Initializes servo on power-up

// Servo Module ADD_PATHPOINT frequency definitions
#define P_30HZ              30  //  30 hz path resolution
#define P_60HZ              60  //  60 hz path resolution
#define P_120HZ            120  // 120 hz path resolution

// Servo Module Status byte bit definitions:
#define MOVE_DONE         0x01  // set when move done (trap. pos mode), when goal
                                // vel. has been reached (vel mode) or when not servoing
#define CKSUM_ERROR       0x02  // checksum error in received command
#define OVERCURRENT       0x04  // set on overcurrent condition (sticky bit)
#define POWER_ON          0x08  // set when motor power is on
#define POS_ERR           0x10  // set on excess pos. error (sticky bit)
#define LIMIT1            0x20  // value of limit 1 input
#define LIMIT2            0x40  // value of limit 2 input
#define HOME_IN_PROG      0x80  // set while searching for home, cleared when home found

// Servo Module Auxilliary status byte bit definitions:
#define INDEX             0x01  // value of the encoder index signal
#define POS_WRAP          0x02  // set when 32 bit position counter wraps around
     	     			              // (sticky bit)
#define SERVO_ON          0x04  // set when position servo is operating
#define ACCEL_DONE        0x08  // set when acceleration portion of a move is done
#define SLEW_DONE         0x10  // set when slew portion of a move is done
#define SERVO_OVERRUN     0x20  // set if servo takes longer than the specified
     				                 // servo period to execute
#define PATH_MODE         0x40  // path mode is enabled

// ---------------------- MODULE STRUCTURE --------------------------------

typedef struct _GAINVECT {
  int  kp;              // gain values
  int  kd;
  int  ki;
  int  il;
  byte ol;
  byte cl;
  int  el;
  byte sr;
  byte dc;
} GAINVECT;

typedef struct _SERVOMOD {
  long   pos;           // current position
  byte   ad;            // a-d value
  int    vel;           // current velocity
  byte   aux;           // auxilliary status byte
  long   home;          // home position
  int    perror;        // position error
  byte   inport1;       // input port 1
  byte   inport2;       // input port 2
  byte   inport3;       // input port 3
// The following data is stored locally for reference
  long   cmdpos;        // last commanded position
  long   cmdvel;        // last commanded velocity
  long   cmdacc;        // last commanded acceleration
  byte   cmdpwm;        // last commanded PWM value
  byte   cmdadc;        // last commanded External position
  GAINVECT   gain;
  long   stoppos;       // motor stop position (used by stop command)
  byte   outport1;      // output port val (used by I-O control)
  byte   outport2;      // output port val (used by I-O control)
  byte   outport3;      // output port val (used by I-O control)
  byte   outport4;      // output port val (used by I-O control)
  byte   stopctrl;      // stop control byte
  byte   movectrl;      // load_traj control byte
  byte   ioctrl;        // I-O control byte
  byte   homectrl;      // homing control byte
  byte   servoinit;     // set to 1 for servo on powerup, zero otherwise
  byte   stp_dir_mode;  // step-direction mode
  byte   advmode;       // 0 - LS-173 mode, 1 - advanced mode
  byte   npoints;       // number of points in path buffer
  long   last_ppoint;   // last path point specified
} SERVOMOD;
/*** EndHeader */


//---------------------------------------------------------------------------
// S T E P P E R  C O N S T A N T S -----------------------------------------
//---------------------------------------------------------------------------


/* START FUNCTION DESCRIPTION ********************************************
StepperConstants             <Ldcn.lib>

-- Step Module Command set:
#define RESET_POS         0x00  -- Reset encoder counter to 0 (0 bytes)
#define SET_ADDR          0x01  -- Set address and group address (2 bytes)
#define DEF_STAT          0x02  -- Define status items to return (1 byte)
#define READ_STAT         0x03  -- Read value of current status items
#define LOAD_TRAJ         0x04  -- Load trajectory data
#define START_MOVE        0x05  -- Start pre-loaded trajectory (0 bytes)
#define SET_PARAM         0x06  -- Set operating parameters (6 bytes)
#define STOP_MOTOR        0x07  -- Stop motor (1 byte)
#define SET_OUTPUTS       0x08  -- Set output bits (1 byte)
#define SET_HOMING        0x09  -- Define homing mode (1 byte)
#define SET_BAUD          0x0A  -- Set the baud rate (1 byte)
#define RESERVED          0x0B  --
#define SAVE_AS_HOME      0x0C  -- Store the input bytes and timer val (0 bytes)
#define NOT_USED          0x0D  --
#define NOP               0x0E  -- No operation - returns prev. defined status (0 bytes)
#define HARD_RESET        0x0F  -- RESET - no status is returned

-- Step Module STATUSITEMS bit definitions:
#define SEND_POS          0x01  -- 4 bytes data
#define SEND_AD           0x02  -- 1 byte
#define SEND_ST           0x04  -- 2 bytes
#define SEND_INBYTE       0x08  -- 1 byte
#define SEND_HOME         0x10  -- 4 bytes
#define SEND_ID           0x20  -- 2 bytes
#define SEND_OUT          0x40  -- 1 byte

-- Step Module LOAD_TRAJ control byte bit definitions:
#define LOAD_POS          0x01  -- +4 bytes
#define LOAD_SPEED        0x02  -- +1 bytes
#define LOAD_ACC          0x04  -- +1 bytes
#define LOAD_ST           0x08  -- +3 bytes
#define STEP_REV          0x10  -- reverse dir
#define START_NOW         0x80  -- 1 = start now, 0 = wait for START_MOVE command

-- Step Module SET_PARAM operating mode byte bit definitions:
#define SPEED_8X          0x00  -- use 8x timing
#define SPEED_4X          0x01  -- use 4x timing
#define SPEED_2X          0x02  -- use 2x timing
#define SPEED_1X          0x03  -- use 1x timing
#define IGNORE_LIMITS     0x04  -- Do not stop automatically on limit switches
#define MOFF_LIMIT        0x08  -- Turn Off Motor on Limit
#define MOFF_STOP         0x10  -- Turn Off motor on Stop

-- Step Module STOP_MOTOR control byte bit definitions:
#define STP_ENABLE_AMP    0x01  -- 1 = raise amp enable output, 0 = lower amp enable
#define STOP_ABRUPT       0x04  -- set to stop motor immediately
#define STOP_SMOOTH       0x08  -- set to decellerate motor smoothly

-- Step Module SET_HOMING control byte bit definitions:
#define ON_LIMIT1         0x01  -- home on change in limit 1
#define ON_LIMIT2         0x02  -- home on change in limit 2
#define HOME_MOTOR_OFF    0x04  -- turn motor off when homed
#define ON_HOMESW         0x08  -- home on change in index
#define HOME_STOP_ABRUPT  0x10  -- stop abruptly when homed
#define HOME_STOP_SMOOTH  0x20  -- stop smoothly when homed

-- Step Module Status byte bit definitions:
#define MOTOR_MOVING      0x01  -- Set when motor is moving
--      CKSUM_ERROR       0x02  -- checksum error in received command
#define STP_AMP_ENABLED   0x04  -- set if amplifier is enabled
#define POWER_ON          0x08  -- set when motor power is on
#define AT_SPEED          0x10  -- set if the commanded velocity is reached.
#define VEL_MODE          0x20  -- set when in velocity profile mode
#define TRAP_MODE         0x40  -- set when in trap. profile mode
#define HOME_IN_PROG      0x80  -- set while searching for home, cleared when home found

-- Step Module Input byte bit definitions:
#define ESTOP             0x01  -- emergency stop input
#define AUX_IN1           0x02  -- auxilliary input #1
#define AUX_IN2           0x04  -- auxilliary input #2
#define FWD_LIMIT         0x08  -- forward limit switch
#define REV_LIMIT         0x10  -- reverse limit switch
#define HOME_SWITCH       0x20  -- homing limit switch
END DESCRIPTION **********************************************************/

//---------------------------------------------------------------------------

/*** BeginHeader */
// Step Module Command set:
// #define RESET_POS      0x00  // Reset encoder counter to 0 (0 bytes)
// #define SET_ADDR       0x01  // Set address and group address (2 bytes)
// #define DEF_STAT       0x02  // Define status items to return (1 byte)
// #define READ_STAT      0x03  // Read value of current status items
#define LOAD_TRAJ         0x04  // Load trajectory data
#define START_MOVE        0x05  // Start pre-loaded trajectory (0 bytes)
#define SET_PARAM         0x06  // Set operating parameters (6 bytes)
#define STOP_MOTOR        0x07  // Stop motor (1 byte)
#define SET_OUTPUTS       0x08  // Set output bits (1 byte)
#define SET_HOMING        0x09  // Define homing mode (1 byte)
// #define SET_BAUD       0x0A  // Set the baud rate (1 byte)
#define RESERVED          0x0B  //
#define SAVE_AS_HOME      0x0C  // Store the input bytes and timer val (0 bytes)
#define NOT_USED          0x0D  //
// #define NOP            0x0E  // No operation - returns prev. defined status (0 bytes)
// #define HARD_RESET     0x0F  // RESET - no status is returned

// Step Module STATUSITEMS bit definitions:
#define SEND_POS          0x01  // 4 bytes data
#define SEND_AD           0x02  // 1 byte
#define SEND_ST           0x04  // 2 bytes
#define SEND_INBYTE       0x08  // 1 byte
#define SEND_HOME         0x10  // 4 bytes
// #define SEND_ID        0x20  // 2 bytes
#define SEND_OUT          0x40  // 1 byte

// Step Module LOAD_TRAJ control byte bit definitions:
#define LOAD_POS          0x01  // +4 bytes
#define LOAD_SPEED        0x02  // +1 bytes
#define LOAD_ACC          0x04  // +1 bytes
#define LOAD_ST           0x08  // +3 bytes
#define STEP_REV          0x10  // reverse dir
#define START_NOW         0x80  // 1 = start now, 0 = wait for START_MOVE command

// Step Module SET_PARAM operating mode byte bit definitions:
#define SPEED_8X          0x00  // use 8x timing
#define SPEED_4X          0x01  // use 4x timing
#define SPEED_2X          0x02  // use 2x timing
#define SPEED_1X          0x03  // use 1x timing
#define IGNORE_LIMITS     0x04  // Do not stop automatically on limit switches
#define MOFF_LIMIT        0x08  // Turn Off Motor on Limit
#define MOFF_STOP         0x10  // Turn Off motor on Stop

// Step Module STOP_MOTOR control byte bit definitions:
#define STP_ENABLE_AMP    0x01  // 1 = raise amp enable output, 0 = lower amp enable
#define STOP_ABRUPT       0x04  // set to stop motor immediately
#define STOP_SMOOTH       0x08  // set to decellerate motor smoothly

// Step Module SET_HOMING control byte bit definitions:
#define ON_LIMIT1         0x01  // home on change in limit 1
#define ON_LIMIT2         0x02  // home on change in limit 2
#define HOME_MOTOR_OFF    0x04  // turn motor off when homed
#define ON_HOMESW         0x08  // home on change in index
#define HOME_STOP_ABRUPT  0x10  // stop abruptly when homed
#define HOME_STOP_SMOOTH  0x20  // stop smoothly when homed

// Step Module Status byte bit definitions:
#define MOTOR_MOVING      0x01  // Set when motor is moving
//      CKSUM_ERROR       0x02  // checksum error in received command
#define STP_AMP_ENABLED   0x04  // set if amplifier is enabled
#define POWER_ON          0x08  // set when motor power is on
#define AT_SPEED          0x10  // set if the commanded velocity is reached.
#define VEL_MODE          0x20  // set when in velocity profile mode
#define TRAP_MODE         0x40  // set when in trap. profile mode
#define HOME_IN_PROG      0x80  // set while searching for home, cleared when home found

// Step Module Input byte bit definitions:
#define ESTOP             0x01  // emergency stop input
#define AUX_IN1           0x02  // auxilliary input #1
#define AUX_IN2           0x04  // auxilliary input #2
#define FWD_LIMIT         0x08  // forward limit switch
#define REV_LIMIT         0x10  // reverse limit switch
#define HOME_SWITCH       0x20  // homing limit switch

// ---------------------- MODULE STRUCTURE --------------------------------

typedef struct _STEPMOD {
  long     pos;         // current position
  byte     ad;          // a/d value
  unsigned int st;      // current step time
  byte     inbyte;      // input bits
  long     home;        // home position
// The following data is stored locally for reference
  long     cmdpos;      // last commanded position
  byte     cmdspeed;    // last commanded speed
  byte     cmdacc;      // last commanded acceleration
  int      cmdst;       // last commanded step time
  double   st_period;
  byte     move_mode;   // last commanded move mode
  byte     min_speed;   // minimum running speed
  byte     stopctrl;    // stop control byte
  byte     outbyte;     // output bits
  byte     homectrl;    // homing control byte
  byte     ctrlmode;    // operating control mode byte
  byte     run_pwm;     // pwm for running current limit
  byte     hold_pwm;    // pwm for holding current limit
  byte     therm_limit; // thermal limit
  byte     emergency_acc;
  byte     stat_io;     // IO byte, returned in status packet
} STEPMOD;
/*** EndHeader */


//---------------------------------------------------------------------------
// I O  N O D E  C O N S T A N T S ------------------------------------------
//---------------------------------------------------------------------------


/* START FUNCTION DESCRIPTION ********************************************
IONodeConstants                 <Ldcn.lib>

-- IO Module Command set:
#define	SET_IO_DIR	  0x00	// Set direction of IO bits (2 data bytes)
#define SET_ADDR          0x01  // Set address and group address (2 bytes)
#define DEF_STAT          0x02  // Define status items to return (1 byte)
#define READ_STAT         0x03  // Read value of current status items
#define SET_PWM           0x04  // Immediatley set PWM1 and PWM2 (2 bytes)
#define SYNCH_OUT         0x05  // Output prev. stored PWM & output bytes (0 bytes)
#define SET_OUTPUT        0x06  // Immediately set output bytes
#define SET_SYNCH_OUT     0x07  // Store PWM & outputs for synch'd output (4 bytes)
#define SET_TMR_MODE      0x08  // Set the counter/timer mode (1 byte)
-- Not used               0x09
#define SET_BAUD          0x0A  // Set the baud rate (1 byte)
-- Not used               0x0B
#define SYNCH_INPUT       0x0C  // Store the input bytes and timer val (0 bytes)
-- Not used               0x0D
#define NOP               0x0E  // No operation - returns prev. defined status (0 bytes)
#define HARD_RESET        0x0F  // RESET - no status is returned

-- IO Module STATUSITEMS bit definitions
#define SEND_INPUTS       0x01  // 2 bytes data
#define SEND_AD1          0x02  // 1 byte
#define SEND_AD2          0x04  // 1 byte
#define SEND_AD3          0x08  // 1 byte
#define SEND_TIMER        0x10  // 4 bytes
#define SEND_ID           0x20  // 2 bytes
#define SEND_SYNC_IN      0x40  // 2 bytes
#define SEND_SYNC_TMR     0x80  // 4 bytes

-- IO Module Timer mode definitions
-- Timer mode and resolution may be OR'd together
#define OFFMODE           0x00
#define COUNTERMODE       0x03
#define TIMERMODE         0x01
#define RESx1             0x00
#define RESx2             0x10
#define RESx4             0x20
#define RESx8             0x30
END DESCRIPTION **********************************************************/

//---------------------------------------------------------------------------

/*** BeginHeader */
// IO Module Command set:
#define	SET_IO_DIR	  0x00	// Set direction of IO bits (2 data bytes)
// #define SET_ADDR       0x01  // Set address and group address (2 bytes)
// #define DEF_STAT       0x02  // Define status items to return (1 byte)
// #define READ_STAT      0x03  // Read value of current status items
#define SET_PWM           0x04  // Immediatley set PWM1 and PWM2 (2 bytes)
#define SYNCH_OUT         0x05  // Output prev. stored PWM & output bytes (0 bytes)
#define SET_OUTPUT        0x06  // Immediately set output bytes
#define SET_SYNCH_OUT     0x07  // Store PWM & outputs for synch'd output (4 bytes)
#define SET_TMR_MODE      0x08  // Set the counter/timer mode (1 byte)
// Not used               0x09
// #define SET_BAUD       0x0A  // Set the baud rate (1 byte)
// Not used               0x0B
#define SYNCH_INPUT       0x0C  // Store the input bytes and timer val (0 bytes)
// Not used               0x0D
// #define NOP            0x0E  // No operation - returns prev. defined status (0 bytes)
// #define HARD_RESET     0x0F  // RESET - no status is returned

// IO Module STATUSITEMS bit definitions
#define SEND_INPUTS       0x01  // 2 bytes data
#define SEND_AD1          0x02  // 1 byte
#define SEND_AD2          0x04  // 1 byte
#define SEND_AD3          0x08  // 1 byte
#define SEND_TIMER        0x10  // 4 bytes
// #define SEND_ID        0x20  // 2 bytes
#define SEND_SYNC_IN      0x40  // 2 bytes
#define SEND_SYNC_TMR     0x80  // 4 bytes

// IO Module Timer mode definitions
// Timer mode and resolution may be OR'd together
#define OFFMODE           0x00
#define COUNTERMODE       0x03
#define TIMERMODE         0x01
#define RESx1             0x00
#define RESx2             0x10
#define RESx4             0x20
#define RESx8             0x30

// ---------------------- MODULE STRUCTURE --------------------------------

typedef struct _IOMOD {
  int  inbits;          // input bits
  byte ad1;             // A/D input bytes
  byte ad2;
  byte ad3;
  unsigned long timer;  // timer value
  int  inbits_s;        // synchronized input bytes
  unsigned long timer_s;// synchronized timer value
// The following data is stored locally for reference
  byte pwm1;            // current PWM output values
  byte pwm2;
  byte timermode;       // current timer mode
  int bitdir;	 	//current bit direction values
  int  outbits;         // current output byte values
} IOMOD;
/*** EndHeader */


// ------------------------------------------------------------------------
// L D C N C O M   C O N S T A N T S --------------------------------------
// ------------------------------------------------------------------------


/* START FUNCTION DESCRIPTION ********************************************
LdcNetworkConstants             <Ldcn.lib>

#define MAXSIOERROR 3

-- Define PIC baud rate divisors
#define	PB9600	           129
#define PB19200             63
#define PB57600             20
#define PB115200            10

-- Module type definitions:
#define SERVOMODTYPE         0
#define IOMODTYPE            2
#define STEPMODTYPE          3
#define SERVOHYBTYPE        90

#define ABS_MAXNUMMOD       32

#ifndef MAXNUMMOD                    Default number of modules
  #define MAXNUMMOD         32
#endif

#ifndef MAXNUMMOD1                   Maximum number of modules for the first net
  #define MAXNUMMOD1 MAXNUMMOD
#endif

#ifndef MAXNUMMOD2                   Maximum number of modules for the second net
  #define MAXNUMMOD2 MAXNUMMOD
#endif

#ifndef MAXNUMMOD3                   Maximum number of modules for the third net
  #define MAXNUMMOD3 MAXNUMMOD
#endif

#ifndef MAXNUMMOD4
  #define MAXNUMMOD4 MAXNUMMOD
#endif

#ifndef MAXNUMNET
  #define MAXNUMNET          1
#endif
END DESCRIPTION **********************************************************/

// ------------------------------------------------------------------------

/* ************************************************************************
 *                                                                        *
 *   The following must be created for each new module type:              *
 *   - Data structure XXXMOD                                              *
 *   - Initializer function NewXXXMod                                     *
 *   - Status reading function GetXXXStat                                 *
 *   LdcnInit and SendLdcnCmd must be modified to include calls           *
 *   to the two functions above                                           *
 *                                                                        *
 * ********************************************************************** */


/*** BeginHeader */
#define MAXSIOERROR 3

// Define PIC baud rate divisors
#define	PB9600	           129
#define PB19200             63
#define PB57600             20
#define PB115200            10

// Module type definitions:
#define SERVOMODTYPE         0
#define IOMODTYPE            2
#define STEPMODTYPE          3
#define SERVOHYBTYPE        90

#define ABS_MAXNUMMOD       32

#ifndef MAXNUMMOD
  #define MAXNUMMOD         32
#endif

#ifndef MAXNUMMOD1
  #define MAXNUMMOD1 MAXNUMMOD
#endif

#ifndef MAXNUMMOD2
  #define MAXNUMMOD2 MAXNUMMOD
#endif

#ifndef MAXNUMMOD3
  #define MAXNUMMOD3 MAXNUMMOD
#endif

#ifndef MAXNUMMOD4
  #define MAXNUMMOD4 MAXNUMMOD
#endif

#ifndef MAXNUMNET
  #define MAXNUMNET          1
#endif

typedef struct _LDCNMOD {
  byte modtype;         // module type
  byte modver;          // module version number
  byte statusitems;     // definition of items to be returned
  byte stat;            // status byte
  byte groupaddr;       // current group address
  bool groupleader;     // TRUE if group leader
  union {
    STEPMOD  step;
    SERVOMOD servo;
    IOMOD    io;
  } kind;
} LDCNMOD;

typedef struct _LDCNNET {
  LDCNMOD mod1[MAXNUMMOD1 + 1]; // Array of modules of net 1
#if MAXNUMNET > 1
  LDCNMOD mod2[MAXNUMMOD2 + 1]; // Array of modules of net 2
#endif
#if MAXNUMNET > 2
  LDCNMOD mod3[MAXNUMMOD3 + 1]; // Array of modules of net 3
#endif
#if MAXNUMNET > 3
  LDCNMOD mod4[MAXNUMMOD4 + 1]; // Array of modules of net 4
#endif
  int nummod_A[MAXNUMNET];      // number of modules
  handle ComPort_A[MAXNUMNET];
  long BaudRate_A[MAXNUMNET];
  int SioError_A[MAXNUMNET];
  int IOBusy_A[MAXNUMNET];
} LDCNNET;

//------------------------ GLOBAL DATA ------------------------------------

LDCNNET net;
int net_num;

LDCNMOD *mod; // Array of modules
int nummod, max_nummod;
handle ComPort;
long BaudRate;
int SioError;
int IOBusy;
/*** EndHeader */
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
LdcnSetNet                  <Ldcn.lib>

SYNTAX: bool LdcnSetNet(int netN);

PARAMETER1: <netN> - network number

KEYWORDS: LdcNetworkFunctions

DESCRIPTION: Ldcn.Lib supports up to four RS485 networks, connected to
             com ports 1, 2, 3 or 4.
             If you work with more than one network, use this function to switch
             to certain network.
             To reduce used memory include following definitions:

                #define MAXNUMNET  n  - the number of RS485 networks

             and for every network define:

                #define MAXNUMMOD1 x - the maximum number of modules for network 1
                #define MAXNUMMOD2 x - the maximum number of modules for network 2
                ...
             before

                #use "Ldcn.Lib" statement in your program.

             Default value for MAXNUMNET is 1 and for MAXNUMMOD1 is 32.

RETURN VALUE:  true on success, false if netN is <= 0 or greater than MAXNUMNET
END DESCRIPTION **********************************************************/

/*** Beginheader LdcnSetNet */
bool LdcnSetNet(int netN);
/*** endheader */

nodebug bool LdcnSetNet(int netN) {
  if ((netN < 1) || (netN > MAXNUMNET)) { printf("ERROR in define of MAXNUMNET\n"); return 0; }

  net.nummod_A[net_num - 1] = nummod;
  net.ComPort_A[net_num - 1] = ComPort;
  net.BaudRate_A[net_num - 1] = BaudRate;
  net.SioError_A[net_num - 1] = SioError;
  net.IOBusy_A[net_num - 1] = IOBusy;

  switch (netN) {
    case 1: mod = net.mod1; max_nummod = MAXNUMMOD1; break;
#if MAXNUMNET > 1
    case 2: mod = net.mod2; max_nummod = MAXNUMMOD2; break;
#endif
#if MAXNUMNET > 2
    case 3: mod = net.mod3; max_nummod = MAXNUMMOD3; break;
#endif
#if MAXNUMNET > 3
    case 4: mod = net.mod4; max_nummod = MAXNUMMOD4; break;
#endif
  }
  net_num = netN;                    // Load new working values
  nummod   = net.nummod_A[net_num - 1];
  ComPort  = net.ComPort_A[net_num - 1];
  BaudRate = net.BaudRate_A[net_num - 1];
  SioError = net.SioError_A[net_num - 1];
  IOBusy   = net.IOBusy_A[net_num - 1];

  return 1;
}
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
// S E R V O   M O D U L E  F U N C T I O N S -------------------------------
//---------------------------------------------------------------------------


//--------------------- Servo Module initialization ---------------------------
/*** BeginHeader ServoNewMod */
void ServoNewMod(byte addr);
/*** EndHeader */

void ServoNewMod(byte addr) {
  mod[addr].kind.servo.pos     = 0;
  mod[addr].kind.servo.ad      = 0;
  mod[addr].kind.servo.vel     = 0;
  mod[addr].kind.servo.aux     = 0;
  mod[addr].kind.servo.home    = 0;
  mod[addr].kind.servo.perror  = 0;
  mod[addr].kind.servo.inport1 = 0;
  mod[addr].kind.servo.inport2 = 0;
  mod[addr].kind.servo.inport3 = 0;
  mod[addr].kind.servo.cmdpos  = 0;
  mod[addr].kind.servo.cmdvel  = 0;
  mod[addr].kind.servo.cmdacc  = 0;
  mod[addr].kind.servo.cmdpwm  = 0;
  mod[addr].kind.servo.cmdadc  = 0;

  mod[addr].kind.servo.gain.kp = 0;
  mod[addr].kind.servo.gain.kd = 0;
  mod[addr].kind.servo.gain.ki = 0;
  mod[addr].kind.servo.gain.il = 0;
  mod[addr].kind.servo.gain.ol = 0;
  mod[addr].kind.servo.gain.cl = 0;
  mod[addr].kind.servo.gain.el = 0;
  mod[addr].kind.servo.gain.sr = 1;
  mod[addr].kind.servo.gain.dc = 0;

  mod[addr].kind.servo.stoppos  = 0;
  mod[addr].kind.servo.ioctrl   = IO1_IN | IO2_IN;
  mod[addr].kind.servo.homectrl = 0;
  mod[addr].kind.servo.movectrl = 0;
  mod[addr].kind.servo.stopctrl = 0;
  mod[addr].kind.servo.servoinit= 0;
  mod[addr].kind.servo.stp_dir_mode = 0;
  mod[addr].kind.servo.advmode = 0;
  mod[addr].kind.servo.npoints = 0;
  mod[addr].kind.servo.last_ppoint = 0;
}
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
ServoModuleFunctions                 <Ldcn.lib>

bool ServoGetStat(byte addr);
long ServoGetPos(byte addr);
byte ServoGetAD(byte addr);
int  ServoGetVel(byte addr);
byte ServoGetAux(byte addr);
long ServoGetHome(byte addr);
int  ServoGetPError(byte addr);
byte ServoGetInport1(byte addr);
byte ServoGetInport2(byte addr);
byte ServoGetInport3(byte addr);
byte ServoGetOutport1(byte addr);
byte ServoGetOutport2(byte addr);
byte ServoGetOutport3(byte addr);
byte ServoGetOutport4(byte addr);
long ServoGetCmdPos(byte addr);
long ServoGetCmdVel(byte addr);
long ServoGetCmdAcc(byte addr);
byte ServoGetCmdPwm(byte addr);
byte ServoGetCmdAdc(byte addr);
byte ServoGetIoCtrl(byte addr);
byte ServoGetHomeCtrl(byte addr);
byte ServoGetStopCtrl(byte addr);
byte ServoGetMoveCtrl(byte addr);
byte ServoGetServoInit(byte addr);
byte ServoGetSDMode(byte addr);
void ServoGetGain(byte addr, int * kp, int * kd, int * ki, int * il, byte * ol,
                  byte * cl, int * el, byte * sr, byte * dc);
bool ServoSetGain(byte addr, int kp, int kd, int ki, int il, byte ol,
                  byte cl, int el, byte sr, byte dc);
bool ServoLoadTraj(byte addr, byte mode, long pos, long vel, long acc, byte pwm);
bool ServoStartMotion(byte groupaddr);
bool ServoResetPos(byte addr);
bool ServoClearBits(byte addr);
bool ServoStopMotor(byte addr, byte mode);
bool ServoSetHoming(byte addr, byte mode);
bool ServoSetOutputs(byte addr, byte mode, byte out1, byte out2, byte out3, byte out4);
bool ServoEEPROMCtrl(byte addr, byte mode, byte out1, byte out2, byte out3, byte out4);
byte ServoGetNPoints(byte addr);
bool ServoSetFastPath(byte addr, bool fast_path);
bool ServoResetRelHome(byte addr);
void ServoInitPath(byte addr);
bool ServoAddPathPoints(byte addr, int npoints, long *path, bool high_freq);
bool ServoStartPathMode(byte groupaddr);
END DESCRIPTION **********************************************************/


/* START FUNCTION DESCRIPTION ********************************************
ServoGetStat                  <Ldcn.lib>

SYNTAX: bool ServoGetStat (byte addr);

PARAMETER1: <addr> - module address

KEYWORDS: ServoModuleFunctions

DESCRIPTION: Receives the status data of a specified Servo module according
             to the last defined by LdcnDefineStatus () status items.

RETURN VALUE:  true on success, false on failure
END DESCRIPTION **********************************************************/

/*** BeginHeader ServoGetStat */
     bool ServoGetStat(byte addr);
/*** EndHeader */

bool ServoGetStat(byte addr) {
  int numbytes, numrcvd;
  int i, bytecount;
  byte cksum;
  byte inbuf[32];

// Find number of bytes to read:
  numbytes = 2;                   // start with stat & cksum
  if ( (mod[addr].statusitems) & SEND_POS  ) numbytes +=4;
  if ( (mod[addr].statusitems) & SEND_AD   ) numbytes +=1;
  if ( (mod[addr].statusitems) & SEND_VEL  ) numbytes +=2;
  if ( (mod[addr].statusitems) & SEND_AUX  ) numbytes +=1;
  if ( (mod[addr].statusitems) & SEND_HOME ) numbytes +=4;
  if ( (mod[addr].statusitems) & SEND_ID   ) numbytes +=2;

  if ((mod[addr].modver > 4) || (mod[addr].modtype == SERVOHYBTYPE)) {
    if ( (mod[addr].statusitems) & SEND_PERROR ) numbytes +=2;
    if ((mod[addr].modver >=60) && (mod[addr].modver < 70))
      if ( mod[addr].statusitems  & SEND_INPORTS) numbytes +=3;
    if (mod[addr].kind.servo.advmode && (mod[addr].statusitems & SEND_NPOINTS)) numbytes +=1;
  }

  numrcvd = SioGetChars(ComPort, (char *)inbuf, numbytes);

// Verify enough data was read
  if (numrcvd != numbytes)
     return false;

// Verify checksum:
  cksum = 0;
  for (i = 0; i < numbytes-1; i++) cksum = (byte)(cksum + inbuf[i]);
  if (cksum != inbuf[numbytes-1])
      return false;

// Verify command was received intact before updating status data
  mod[addr].stat = inbuf[0];
  if (mod[addr].stat & CKSUM_ERROR)
      return false;

// Finally, fill in status data
  bytecount = 1;
  if ( (mod[addr].statusitems) & SEND_POS ) {
     mod[addr].kind.servo.pos = *( (long *)(inbuf + bytecount) );
     bytecount +=4;
  }
  if ( (mod[addr].statusitems) & SEND_AD )  {
     mod[addr].kind.servo.ad = inbuf[bytecount];
     bytecount +=1;
  }
  if ( (mod[addr].statusitems) & SEND_VEL ) {
     mod[addr].kind.servo.vel = *( (int *)(inbuf + bytecount) );
     bytecount +=2;
  }
  if ( (mod[addr].statusitems) & SEND_AUX ) {
     mod[addr].kind.servo.aux = inbuf[bytecount];
     bytecount +=1;
  }
  if ( (mod[addr].statusitems) & SEND_HOME ) {
     mod[addr].kind.servo.home = *( (unsigned long *)(inbuf + bytecount) );
     bytecount +=4;
  }
  if ( (mod[addr].statusitems) & SEND_ID ) {
     mod[addr].modtype = inbuf[bytecount];
     mod[addr].modver = inbuf[bytecount+1];
     bytecount +=2;
  }
  if ( (mod[addr].statusitems) & SEND_PERROR )
   if ( (mod[addr].modver > 4) || (mod[addr].modtype == SERVOHYBTYPE))  {
     mod[addr].kind.servo.perror = *( (int *)(inbuf + bytecount) );
     bytecount +=2;
  }
  if ( (mod[addr].statusitems & SEND_NPOINTS) && mod[addr].kind.servo.advmode ) {
     mod[addr].kind.servo.npoints = inbuf[bytecount];
     bytecount +=1;
  }

  if ( (mod[addr].statusitems & SEND_INPORTS) &&               // check for v6x
       (mod[addr].modver >=60) && (mod[addr].modver < 70)) {
     mod[addr].kind.servo.inport1 = inbuf[bytecount++];
     mod[addr].kind.servo.inport2 = inbuf[bytecount++];
     mod[addr].kind.servo.inport3 = inbuf[bytecount++];
  }
  return true;
}
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
ServoGetPos                  <Ldcn.lib>

SYNTAX: long ServoGetPos (byte addr);

PARAMETER1: <addr> - module address

KEYWORDS: ServoModuleFunctions

DESCRIPTION: Returns the current motor position of a SERVO module.
             Note: this data is only valid if the SEND_POS bit has been
             set in the most recently issued LdcnDefineStatus () command.

RETURN VALUE: current motor position of a SERVO module
END DESCRIPTION **********************************************************/

/*** BeginHeader ServoGetPos */
     long ServoGetPos(byte addr);
/*** EndHeader */

long ServoGetPos(byte addr) {  return mod[addr].kind.servo.pos; }
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
ServoGetAD                  <Ldcn.lib>

SYNTAX: byte ServoGetAD (byte addr);

PARAMETER1: <addr> - module address

KEYWORDS: ServoModuleFunctions

DESCRIPTION: Returns the current A/D value of a SERVO module.
             Note: this data is only valid if the SEND_AD bit has been
             set in the most recently issued LdcnDefineStatus () command.

RETURN VALUE: current A/D value of a SERVO module
END DESCRIPTION **********************************************************/

/*** BeginHeader ServoGetAD */
     byte ServoGetAD(byte addr);
/*** EndHeader */

byte ServoGetAD(byte addr) {  return mod[addr].kind.servo.ad; }
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
ServoGetVel                 <Ldcn.lib>

SYNTAX: int ServoGetVel (byte addr);

PARAMETER1: <addr> - module address

KEYWORDS: ServoModuleFunctions

DESCRIPTION: Returns the current motor velocity of a SERVO module.
             Note: this data is only valid if the SEND_VEL bit has been
             set in the most recently issued LdcnDefineStatus () command.

RETURN VALUE: current motor velocity of a SERVO module.
END DESCRIPTION **********************************************************/

/*** BeginHeader ServoGetVel */
     int ServoGetVel(byte addr);
/*** EndHeader */

int ServoGetVel(byte addr) {  return mod[addr].kind.servo.vel; }
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
ServoGetAux                  <Ldcn.lib>

SYNTAX: byte ServoGetAux (byte addr);

PARAMETER1: <addr> - module address

KEYWORDS: ServoModuleFunctions

DESCRIPTION: Returns the current auxiliary status byte of a SERVO module.
             Note: this data is only valid if the SEND_AUX bit has been
             set in the most recently issued LdcnDefineStatus () command.

RETURN VALUE: current auxiliary status byte of a SERVO module
END DESCRIPTION **********************************************************/

/*** BeginHeader ServoGetAux */
     byte ServoGetAux(byte addr);
/*** EndHeader */

byte ServoGetAux(byte addr) {  return mod[addr].kind.servo.aux; }
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
ServoGetHome                  <Ldcn.lib>

SYNTAX: long ServoGetHome (byte addr);

PARAMETER1: <addr> - module address

KEYWORDS: ServoModuleFunctions

DESCRIPTION: Returns the current motor home position of a SERVO module.
             Note: this data is only valid if the SEND_HOME bit has been
             set in the most recently issued LdcnDefineStatus () command.

RETURN VALUE: current motor home position of a SERVO module
END DESCRIPTION **********************************************************/

/*** BeginHeader ServoGetHome */
     long ServoGetHome(byte addr);
/*** EndHeader */

long ServoGetHome(byte addr) {  return mod[addr].kind.servo.home; }
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
ServoGetPError                 <Ldcn.lib>

SYNTAX: int ServoGetPError (byte addr);

PARAMETER1: <addr> - module address

KEYWORDS: ServoModuleFunctions

DESCRIPTION: Returns the current position error of a SERVO module.
             Note: this data is only valid if the SEND_PERROR bit has
             been set in the most recently issued LdcnDefineStatus()
             command and the module version is greater than 5.

RETURN VALUE: current position error of a SERVO module
END DESCRIPTION **********************************************************/

/*** BeginHeader ServoGetPError */
     int ServoGetPError(byte addr);
/*** EndHeader */

int ServoGetPError(byte addr) {  return mod[addr].kind.servo.perror; }
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
ServoGetInport1                  <Ldcn.lib>

SYNTAX: byte ServoGetInport1 (byte addr);

PARAMETER1: <addr> - module address

KEYWORDS: ServoModuleFunctions

DESCRIPTION: Return the current value of input port 1.
             Note: This data is only valid if the SEND_INPORTS bit has been
             set in the most recently issued LdcnDefineStatus () command and
             the module version is greater or equal than 60 and less than 70.

RETURN VALUE: current value of input port 1
END DESCRIPTION **********************************************************/

/*** BeginHeader ServoGetInport1 */
     byte ServoGetInport1(byte addr);
/*** EndHeader */

byte ServoGetInport1(byte addr) {  return mod[addr].kind.servo.inport1; }
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
ServoGetInport2                  <Ldcn.lib>

SYNTAX: byte ServoGetInport2 (byte addr);

PARAMETER1: <addr> - module address

KEYWORDS: ServoModuleFunctions

DESCRIPTION: Return the current value of input port 2.
             Note: This data is only valid if the SEND_INPORTS bit has been
             set in the most recently issued LdcnDefineStatus () command and
             the module version is greater or equal than 60 and less than 70.

RETURN VALUE: current value of input port 2
END DESCRIPTION **********************************************************/

/*** BeginHeader ServoGetInport2 */
     byte ServoGetInport2(byte addr);
/*** EndHeader */

byte ServoGetInport2(byte addr) {  return mod[addr].kind.servo.inport2; }
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
ServoGetInport3                  <Ldcn.lib>

SYNTAX: byte ServoGetInport3 (byte addr);

PARAMETER1: <addr> - module address

KEYWORDS: ServoModuleFunctions

DESCRIPTION: Return the current value of input port 3.
             Note: This data is only valid if the SEND_INPORTS bit has been
             set in the most recently issued LdcnDefineStatus () command and
             the module version is greater or equal than 60 and less than 70.

RETURN VALUE: current value of input port 3
END DESCRIPTION **********************************************************/

/*** BeginHeader ServoGetInport3 */
     byte ServoGetInport3(byte addr);
/*** EndHeader */

byte ServoGetInport3(byte addr) {  return mod[addr].kind.servo.inport3; }
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
ServoGetOutport1                  <Ldcn.lib>

SYNTAX: byte ServoGetOutport1 (byte addr);

PARAMETER1: <addr> - module address

KEYWORDS: ServoModuleFunctions

DESCRIPTION: Return the current value of output port 1.
             Note: This data is only valid if the module version
                   is greater or equal than 60 and less than 70.

RETURN VALUE: current value of output port 1
END DESCRIPTION **********************************************************/

/*** BeginHeader ServoGetOutport1 */
     byte ServoGetOutport1(byte addr);
/*** EndHeader */

byte ServoGetOutport1(byte addr) {  return mod[addr].kind.servo.outport1; }
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
ServoGetOutport2                  <Ldcn.lib>

SYNTAX: byte ServoGetOutport2 (byte addr);

PARAMETER1: <addr> - module address

KEYWORDS: ServoModuleFunctions

DESCRIPTION: Return the current value of output port 2.
             Note: This data is only valid if the module version
                   is greater or equal than 60 and less than 70.

RETURN VALUE: current value of output port 2
END DESCRIPTION **********************************************************/

/*** BeginHeader ServoGetOutport2 */
     byte ServoGetOutport2(byte addr);
/*** EndHeader */

byte ServoGetOutport2(byte addr) {  return mod[addr].kind.servo.outport2; }
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
ServoGetOutport3                  <Ldcn.lib>

SYNTAX: byte ServoGetOutport3 (byte addr);

PARAMETER1: <addr> - module address

KEYWORDS: ServoModuleFunctions

DESCRIPTION: Return the current value of output port 3.
             Note: This data is only valid if the module version
                   is greater or equal than 60 and less than 70.

RETURN VALUE: current value of output port 3
END DESCRIPTION **********************************************************/

/*** BeginHeader ServoGetOutport3 */
     byte ServoGetOutport3(byte addr);
/*** EndHeader */

byte ServoGetOutport3(byte addr) {  return mod[addr].kind.servo.outport3; }
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
ServoGetOutport4                  <Ldcn.lib>

SYNTAX: byte ServoGetOutport4 (byte addr);

PARAMETER1: <addr> - module address

KEYWORDS: ServoModuleFunctions

DESCRIPTION: Return the current value of output port 4.
             Note: This data is only valid if the module version
                   is greater or equal than 60 and less than 70.

RETURN VALUE: current value of output port 4
END DESCRIPTION **********************************************************/

/*** BeginHeader ServoGetOutport4 */
     byte ServoGetOutport4(byte addr);
/*** EndHeader */

byte ServoGetOutport4(byte addr) {  return mod[addr].kind.servo.outport4; }
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
ServoGetCmdPos                  <Ldcn.lib>

SYNTAX: long ServoGetCmdPos (byte addr);

PARAMETER1: <addr> - module address

KEYWORDS: ServoModuleFunctions

DESCRIPTION: Returns the last used command position for a SERVO module.

RETURN VALUE: the last command position for a SERVO module
END DESCRIPTION **********************************************************/

/*** BeginHeader ServoGetCmdPos */
     long ServoGetCmdPos(byte addr);
/*** EndHeader */

long ServoGetCmdPos(byte addr) {  return mod[addr].kind.servo.cmdpos; }
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
ServoGetCmdVel                   <Ldcn.lib>

SYNTAX: long ServoGetCmdVel (byte addr);

PARAMETER1: <addr> - module address

KEYWORDS: ServoModuleFunctions

DESCRIPTION: Returns the last used command velocity for a SERVO module.

RETURN VALUE: the last command velocity for a SERVO module
END DESCRIPTION **********************************************************/

/*** BeginHeader ServoGetCmdVel */
     long ServoGetCmdVel(byte addr);
/*** EndHeader */

long ServoGetCmdVel(byte addr) {  return mod[addr].kind.servo.cmdvel; }
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
ServoGetCmdAcc                  <Ldcn.lib>

SYNTAX: long ServoGetCmdAcc (byte addr);

PARAMETER1: <addr> - module address

KEYWORDS: ServoModuleFunctions

DESCRIPTION: Returns the last used command acceleration for a SERVO module.

RETURN VALUE: the last command acceleration for a SERVO module
 END DESCRIPTION **********************************************************/

/*** BeginHeader ServoGetCmdAcc */
     long ServoGetCmdAcc(byte addr);
/*** EndHeader */

long ServoGetCmdAcc(byte addr) {  return mod[addr].kind.servo.cmdacc; }
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
ServoGetCmdPwm                  <Ldcn.lib>

SYNTAX: byte ServoGetCmdPwm (byte addr);

PARAMETER1: <addr> - module address

KEYWORDS: ServoModuleFunctions

DESCRIPTION: Returns the PWM value of the most recently issued
             function ServoLoadTraj () with LOAD_PWM bit set in
             the mode byte for a SERVO module.

RETURN VALUE: the last commanded PWM value sent to a SERVO module
END DESCRIPTION **********************************************************/

/*** BeginHeader ServoGetCmdPwm */
     byte ServoGetCmdPwm(byte addr);
/*** EndHeader */

byte ServoGetCmdPwm(byte addr) {  return mod[addr].kind.servo.cmdpwm; }
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
ServoGetCmdAdc                  <Ldcn.lib>

SYNTAX: byte ServoGetCmdAdc (byte addr);

PARAMETER1: <addr> - module address

KEYWORDS: ServoModuleFunctions

DESCRIPTION: Returns the last commanded absolute position sent with
             function ServoLoadTraj (). This function works with
             LS-173AP servo controller only.

RETURN VALUE: the last commanded absolute position
END DESCRIPTION **********************************************************/

/*** BeginHeader ServoGetCmdAdc */
     byte ServoGetCmdAdc(byte addr);
/*** EndHeader */

byte ServoGetCmdAdc(byte addr) { return mod[addr].kind.servo.cmdadc; }
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
ServoGetIoCtrl                  <Ldcn.lib>

SYNTAX: byte ServoGetIoCtrl (byte addr);

PARAMETER1: <addr> - module address

KEYWORDS: ServoModuleFunctions

DESCRIPTION: Returns the most recently issued I/O
             command control byte for a SERVO module.

RETURN VALUE: the last issued I/O command control byte
END DESCRIPTION **********************************************************/

/*** BeginHeader ServoGetIoCtrl */
     byte ServoGetIoCtrl(byte addr);
/*** EndHeader */

byte ServoGetIoCtrl(byte addr) {  return mod[addr].kind.servo.ioctrl; }
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
ServoGetHomeCtrl                  <Ldcn.lib>

SYNTAX: byte ServoGetHomeCtrl (byte addr);

PARAMETER1: <addr> - module address

KEYWORDS: ServoModuleFunctions

DESCRIPTION: Returns the home mode control byte the most recently
             issued function ServoSetHoming () for a SERVO module.

RETURN VALUE: home mode control byte for a SERVO module.
END DESCRIPTION **********************************************************/

/*** BeginHeader ServoGetHomeCtrl */
     byte ServoGetHomeCtrl(byte addr);
/*** EndHeader */

byte ServoGetHomeCtrl(byte addr) {  return mod[addr].kind.servo.homectrl; }
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
ServoGetStopCtrl                  <Ldcn.lib>

SYNTAX:xmem byte ServoGetStopCtrl (byte addr);

PARAMETER1: <addr> - module address

KEYWORDS: ServoModuleFunctions

DESCRIPTION: Returns the stop mode control byte of the most recently
             issued function ServoStopMotor() for a SERVO module.

RETURN VALUE: stop mode control byte for a SERVO module
END DESCRIPTION **********************************************************/

/*** BeginHeader ServoGetStopCtrl */
     byte ServoGetStopCtrl(byte addr);
/*** EndHeader */

byte ServoGetStopCtrl(byte addr) {  return mod[addr].kind.servo.stopctrl; }
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
ServoGetMoveCtrl                  <Ldcn.lib>

SYNTAX: byte ServoGetMoveCtrl (byte addr);

PARAMETER1: <addr> - module address

KEYWORDS: ServoModuleFunctions

DESCRIPTION: Returns the move mode control byte of the most recently
             issued function ServoLoadTraj() for a SERVO module.

RETURN VALUE: move mode control byte for a SERVO module
END DESCRIPTION **********************************************************/

/*** BeginHeader ServoGetMoveCtrl */
     byte ServoGetMoveCtrl(byte addr);
/*** EndHeader */

byte ServoGetMoveCtrl(byte addr) {  return mod[addr].kind.servo.movectrl; }
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
ServoGetServoInit                  <Ldcn.lib>

SYNTAX: byte ServoGetServoInit (byte addr);

PARAMETER1: <addr> - module address

KEYWORDS: ServoModuleFunctions

DESCRIPTION: Returns Servo init state (1 for servo on power-up)
             of SERVO device with version greater or equal
             than 60 and less than 70.

RETURN VALUE: Servo init state of SERVO device
END DESCRIPTION **********************************************************/

/*** BeginHeader ServoGetServoInit */
     byte ServoGetServoInit(byte addr);
/*** EndHeader */

byte ServoGetServoInit(byte addr) {  return mod[addr].kind.servo.servoinit; }
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
ServoGetSDMode                  <Ldcn.lib>

SYNTAX: byte ServoGetSDMode (byte addr);

PARAMETER1: <addr> - module address

KEYWORDS: ServoModuleFunctions

DESCRIPTION: Returns 1 if the Servo module at address addr is in
             Step & Direction mode and 0 otherwise. The module version
             must be greater or equal than 60 and less than 70.

RETURN VALUE: 1 or 0
END DESCRIPTION **********************************************************/

/*** BeginHeader ServoGetSDMode */
     byte ServoGetSDMode(byte addr);
/*** EndHeader */

byte ServoGetSDMode(byte addr) {  return mod[addr].kind.servo.stp_dir_mode; }
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
ServoGetGain                  <Ldcn.lib>

SYNTAX: void ServoGetGain (byte addr, int * kp, int * kd, int * ki,
         int * il, byte * ol, byte * cl, int * el, byte * sr, byte * dc);

PARAMETER1:  <addr> - module address
PARAMETER2:  <kp>   - kp
PARAMETER3:  <kd>   - kd
PARAMETER4:  <ki>   - ki
PARAMETER5:  <il>   - il
PARAMETER6:  <ol>   - PWM limit
PARAMETER7:  <cl>   - current limit
PARAMETER8:  <el>   - position error limit
PARAMETER9:  <sr>   - servo rate
PARAMETER10: <dc>   - deadband compensation

KEYWORDS: ServoModuleFunctions

DESCRIPTION: Returns the most recently issued servo gain values for a SERVO module.

RETURN VALUE: none
END DESCRIPTION **********************************************************/

/*** BeginHeader ServoGetGain */
     void ServoGetGain(byte addr, int * kp, int * kd, int * ki, int * il, byte * ol, byte * cl, int * el, byte * sr, byte * dc);
/*** EndHeader */

void ServoGetGain(byte addr, int * kp, int * kd, int * ki,
	 int * il, byte * ol, byte * cl, int * el, byte * sr, byte * dc) {
  *kp = mod[addr].kind.servo.gain.kp;
  *kd = mod[addr].kind.servo.gain.kd;
  *ki = mod[addr].kind.servo.gain.ki;
  *il = mod[addr].kind.servo.gain.il;
  *ol = mod[addr].kind.servo.gain.ol;
  *cl = mod[addr].kind.servo.gain.cl;
  *el = mod[addr].kind.servo.gain.el;
  *sr = mod[addr].kind.servo.gain.sr;
  *dc = mod[addr].kind.servo.gain.dc;
}
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
ServoSetGain                  <Ldcn.lib>

SYNTAX: bool ServoSetGain (byte addr, int kp, int kd, int ki,
         int il, byte ol, byte cl, int el, byte sr, byte dc);

PARAMETER1:  <addr> - module address
PARAMETER2:  <kp>   - kp
PARAMETER3:  <kd>   - kd
PARAMETER4:  <ki>   - ki
PARAMETER5:  <il>   - il
PARAMETER6:  <ol>   - PWM limit
PARAMETER7:  <cl>   - current limit
PARAMETER8:  <el>   - position error limit
PARAMETER9:  <sr>   - servo rate
PARAMETER10: <dc>   - deadband compensation

KEYWORDS: ServoModuleFunctions

DESCRIPTION: Sets the servo gains for a SERVO module.

RETURN VALUE: true on success, false on failure
END DESCRIPTION **********************************************************/

/*** BeginHeader ServoSetGain */
     bool ServoSetGain(byte addr, int kp, int kd, int ki, int il, byte ol, byte cl, int el, byte sr, byte dc);
/*** EndHeader */

bool ServoSetGain(byte addr, int kp, int kd, int ki,
         int il, byte ol, byte cl, int el, byte sr, byte dc) {
char cmdstr[16];

  mod[addr].kind.servo.gain.kp = kp;
  mod[addr].kind.servo.gain.kd = kd;
  mod[addr].kind.servo.gain.ki = ki;
  mod[addr].kind.servo.gain.il = il;
  mod[addr].kind.servo.gain.ol = ol;
  mod[addr].kind.servo.gain.cl = cl;
  mod[addr].kind.servo.gain.el = el;
  mod[addr].kind.servo.gain.sr = sr;
  mod[addr].kind.servo.gain.dc = dc;

  *( (int  *)(cmdstr   ) ) = kp;
  *( (int  *)(cmdstr+ 2) ) = kd;
  *( (int  *)(cmdstr+ 4) ) = ki;
  *( (int  *)(cmdstr+ 6) ) = il;
  *( (byte *)(cmdstr+ 8) ) = ol;
  *( (byte *)(cmdstr+ 9) ) = cl;
  *( (int  *)(cmdstr+10) ) = el;
  *( (byte *)(cmdstr+12) ) = sr;
  *( (byte *)(cmdstr+13) ) = dc;

  return LdcnSendCmd(addr, SET_GAIN, cmdstr, 14);
}
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
ServoLoadTraj                  <Ldcn.lib>

SYNTAX: bool ServoLoadTraj (byte addr, byte mode,
                 long pos, long vel, long acc, byte pwm);

PARAMETER1:  <addr> - module address
PARAMETER2:  <mode> - trajectory control byte
PARAMETER3:  <pos>  - position value
PARAMETER4:  <vel>  - velosity value
PARAMETER5:  <acc>  - acceleration value
PARAMETER6:  <pwm>  - PWM value

KEYWORDS: ServoModuleFunctions

DESCRIPTION: Loads motion trajectory information for a SERVO module. Mode is the
             load trajectory control byte, and should be set to the bitwise
             OR of the trajectory control byte bits. Note that if the START_NOW
             bit is set, the motion will begin immediately.
             If it is not set, the motion will be started  when
             ServoStartMotiont () is called with the module's address.

RETURN VALUE: true on success, false on failure
END DESCRIPTION **********************************************************/

/*** BeginHeader ServoLoadTraj */
     bool ServoLoadTraj(byte addr, byte mode, long pos, long vel, long acc, byte pwm);
/*** EndHeader */

bool ServoLoadTraj(byte addr, byte mode, long pos, long vel, long acc, byte pwm) {
  char cmdstr[16];
  int count;

  mod[addr].kind.servo.movectrl = mode;

  count = 0;
  *( (byte *)(cmdstr + count) ) = mode;  count += 1;

  if (mode & LOAD_POS)  {
    mod[addr].kind.servo.cmdpos = pos;
    *( (long *)(cmdstr + count) ) = pos;
    count += 4;
  }
  if (mode & LOAD_VEL)  {
    mod[addr].kind.servo.cmdvel = vel;
    *( (long *)(cmdstr + count) ) = vel;
    count += 4;
  }
  if (mode & LOAD_ACC)  {
    mod[addr].kind.servo.cmdacc = acc;
    *( (long *)(cmdstr + count) ) = acc;
    count += 4;
  }
  if (mode & LOAD_PWM)  {
    if (mode & LOAD_VEL)
      mod[addr].kind.servo.cmdadc = pwm; // ADC pos
    else
      mod[addr].kind.servo.cmdpwm = pwm;
    *( (byte *)(cmdstr + count) ) = pwm;
    count += 1;
  }

  return LdcnSendCmd(addr, LOAD_TRAJ, cmdstr, (byte)count);
}
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
ServoStartMotion                  <Ldcn.lib>

SYNTAX: bool ServoStartMotion (byte groupaddr);

PARAMETER1: <groupaddr> - group address

KEYWORDS: ServoModuleFunctions

DESCRIPTION: This will cause a SERVO module to execute
             a previously loaded trajectory.

RETURN VALUE: true on success, false on failure
END DESCRIPTION **********************************************************/

/*** BeginHeader ServoStartMotion */
     bool ServoStartMotion(byte groupaddr);
/*** EndHeader */

bool ServoStartMotion(byte groupaddr) { return LdcnSendCmd(groupaddr, START_MOVE, NULL, 0); }
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
ServoResetPos                   <Ldcn.lib>

SYNTAX: bool ServoResetPos (byte addr);

PARAMETER1: <addr> - module address

KEYWORDS: ServoModuleFunctions

DESCRIPTION: Resets the 32-bit encoder counter to 0. Also resets the
             internal command position to 0 to prevent the motor from
             jumping abruptly if the position servo is enabled. Do not
             issue this command while executing a motion.

RETURN VALUE: true on success, false on failure
END DESCRIPTION **********************************************************/

/*** BeginHeader ServoResetPos */
     bool ServoResetPos(byte addr);
/*** EndHeader */

bool ServoResetPos(byte addr) {  return LdcnSendCmd(addr, RESET_POS, NULL, 0); }
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
ServoClearBits                  <Ldcn.lib>

SYNTAX: bool ServoClearBits (byte addr);

PARAMETER1: <addr> - module address

KEYWORDS: ServoModuleFunctions

DESCRIPTION: Clears the sticky status bits (overcurrent and position
             error bits in the status byte and the position wrap and
             servo timer overrun bits in the auxiliary status byte)
             for a SERVO module. They will stay set unless cleared
             explicitly with this command.

RETURN VALUE: true on success, false on failure
END DESCRIPTION **********************************************************/

/*** BeginHeader ServoClearBits */
     bool ServoClearBits(byte addr);
/*** EndHeader */

bool ServoClearBits(byte addr) {  return LdcnSendCmd(addr, CLEAR_BITS, NULL, 0); }
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
ServoStopMotor                 <Ldcn.lib>

SYNTAX: bool ServoStopMotor (byte addr, byte mode);

PARAMETER1: <addr> - module address
PARAMETER2: <mode> - mode byte

KEYWORDS: ServoModuleFunctions

DESCRIPTION: Stops a motor in the manner specified by mode.
             Mode is the stop control byte, and should be set
             to the bitwise OR of the stop control bits.

RETURN VALUE: true on success, false on failure
END DESCRIPTION **********************************************************/

/*** BeginHeader ServoStopMotor */
     bool ServoStopMotor(byte addr, byte mode);
/*** EndHeader */

void SetStopCtrl(byte addr, byte mode) {

  if ((mod[addr].modtype != SERVOMODTYPE) &&
      (mod[addr].modtype != SERVOHYBTYPE))
      return;

  mod[addr].kind.servo.stopctrl = mode;

// LS-174
  if (mode & ADV_MODE) if ((mod[addr].modver >=70) && (mod[addr].modver < 80))
     mod[addr].kind.servo.advmode = 1;
}


bool ServoStopMotor(byte addr, byte mode) {
int i;

  mode &= (byte)(~STOP_HERE);

  if (addr & 0x80) {                 // addr is a group address
    for (i = 1; i <= nummod; i++)
      if (mod[i].groupaddr == addr)
         SetStopCtrl(i, mode);
  } else SetStopCtrl(addr, mode);

  return LdcnSendCmd(addr, STOP_MOTOR, (char *)(&mode), 1);
}
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
ServoSetHoming                  <Ldcn.lib>

SYNTAX: bool ServoSetHoming (byte addr, byte mode);

PARAMETER1: <addr> - module address
PARAMETER2: <mode> - mode byte

KEYWORDS: ServoModuleFunctions

DESCRIPTION: Starts the homing for SERVO module. Mode is the
             homing control byte and should be set to the bitwise
             OR of the homing control bits. This command sets the
             homing conditions but does not start any motion. The
             HOME_IN_PROG bit of the status byte should be monitored
             to detect when the home position has been captured.

RETURN VALUE: true on success, false on failure
END DESCRIPTION **********************************************************/

/*** BeginHeader ServoSetHoming */
     bool ServoSetHoming(byte addr, byte mode);
/*** EndHeader */

bool ServoSetHoming(byte addr, byte mode) {
  mod[addr].kind.servo.homectrl = mode;
  return LdcnSendCmd(addr, SET_HOMING, (char *)(&mode), 1);
}
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
ServoSetOutputs                  <Ldcn.lib>

SYNTAX: bool ServoSetOutputs (byte addr, byte mode, byte out1,
                                  byte out2, byte out3, byte out4);

PARAMETER1: <addr> - module address
PARAMETER2: <mode> - mode byte
PARAMETER3: <out1> - data byte for outport 1
PARAMETER4: <out2> - data byte for outport 2
PARAMETER5: <out3> - data byte for outport 3
PARAMETER6: <out4> - data byte for outport 4

KEYWORDS: ServoModuleFunctions

DESCRIPTION: Sets some of or all four values of auxiliary ports of a
             SERVO device (with version greater or equal than 60 and
             less than 70). Bits 0 and 1 of the mode byte are not used,
             bits 2 and 3 must be set to 1 (= input).  Bits 4 to 7
             define which of outx function parameters to be written to
             the corresponding out port.

RETURN VALUE: true on success, false on failure
END DESCRIPTION **********************************************************/

/*** BeginHeader ServoSetOutputs */
     bool ServoSetOutputs(byte addr, byte mode, byte out1, byte out2, byte out3, byte out4);
/*** EndHeader */

bool ServoSetOutputs(byte addr, byte mode, byte out1, byte out2, byte out3, byte out4) {
  char cmdstr[8];
  int count;

  cmdstr[0] = mode;
  count = 1;
  if (mode & WR_OUT1)  { mod[addr].kind.servo.outport1 = out1; cmdstr[count++] = out1; }
  if (mode & WR_OUT2)  { mod[addr].kind.servo.outport2 = out2; cmdstr[count++] = out2; }
  if (mode & WR_OUT3)  { mod[addr].kind.servo.outport3 = out3; cmdstr[count++] = out3; }
  if (mode & WR_OUT4)  { mod[addr].kind.servo.outport4 = out4; cmdstr[count++] = out4; }

  mod[addr].kind.servo.ioctrl = mode;
  return LdcnSendCmd(addr, IO_CTRL, cmdstr, (byte)count);
}
//---------------------------------------------------------------------------
// internal use only for ServoEEPROMCtrl

bool ServoReadEEPROM (byte addr, byte mode) {
// Vars for reading back eeprom data
  char eedata[30];
  byte outstr[5];
  int numrcvd;

  outstr[0] = (char) 0xAA;                  // header byte
  outstr[1] = addr;                         // address byte
  outstr[2] = (byte)(EEPROM_CTRL + 0x10);   // command byte
  outstr[3] = 0;                            // mode = 0
  outstr[4] = (byte)(outstr[1] + outstr[2] + outstr[3]);  //cksum

  SioClrInbuf(ComPort);                     // Get rid of any old input chars
  SioPutChars(ComPort, (char *)outstr, 5);  // Send the command string

// Read back 29 chars prior to receiving status packet:
  numrcvd = SioGetChars(ComPort, eedata, 29);

// Verify enough data was read
  if (numrcvd != 29)   return false;

// Store the data in the module's data structure
  if ((mode==0) || (mode & FETCH_GAINS))
      memcpy( &(mod[addr].kind.servo.gain), eedata, sizeof(GAINVECT));

  if ((mode==0) || (mode & FETCH_VA)) {
      mod[addr].kind.servo.cmdvel = *( (long int *)(eedata + 14) );
      mod[addr].kind.servo.cmdacc = *( (long int *)(eedata + 18) );
  }

  if (mode==0) {
     mod[addr].kind.servo.servoinit    = (byte)eedata[23];
     mod[addr].kind.servo.stp_dir_mode = (byte)eedata[28];
  }

  if ((mode==0) || (mode & FETCH_OUTPUTS)) {
      mod[addr].kind.servo.outport1 = (byte)eedata[24];
      mod[addr].kind.servo.outport2 = (byte)eedata[25];
      mod[addr].kind.servo.outport3 = (byte)eedata[26];
      mod[addr].kind.servo.outport4 = (byte)eedata[27];
  }

// read in the normal status packet
  return ServoGetStat(addr);
}
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
ServoEEPROMCtrl                  <Ldcn.lib>

SYNTAX: bool ServoEEPROMCtrl (byte addr, byte mode, byte out1,
                                   byte out2, byte out3, byte out4);

PARAMETER1: <addr> - module address
PARAMETER2: <mode> - mode byte
PARAMETER3: <out1> - data byte for outport 1
PARAMETER4: <out2> - data byte for outport 2
PARAMETER5: <out3> - data byte for outport 3
PARAMETER6: <out4> - data byte for outport 4

KEYWORDS: ServoModuleFunctions

DESCRIPTION:Performs  EEPROM  read  or  write  operations  in  a  SERVO module with
            version greater or equal  than 60 and less  than 70. Mode is  the EEPROM
            control byte and should be set  to the bitwise OR of the  EEPROM control
            bits.
            Note: These commands  normally need more  time to be  executed than
            single execution  loop time  and causes  servo_overrun bit  in auxiliary
            status byte to be  set. This  bit can  be cleared with ServoClearBits ()
            function. Do not use this function when servo is on!

RETURN VALUE: true on success, false on failure
END DESCRIPTION **********************************************************/

/*** BeginHeader ServoEEPROMCtrl */
     bool ServoEEPROMCtrl(byte addr, byte mode, byte out1, byte out2, byte out3, byte out4);
/*** EndHeader */

bool ServoEEPROMCtrl(byte addr, byte mode, byte out1, byte out2, byte out3, byte out4) {
  char cmdstr[8];
  int count;

  if (mod[addr].modver < 60 || mod[addr].modver >= 70) return(false);   // punt if not EEPROM

  if (mode != 0) {              // normal execution if setting or restoring data
    if ((mode & FETCH_GAINS) || (mode & FETCH_VA) || (mode & FETCH_OUTPUTS))
      if (!ServoReadEEPROM(addr, mode))
         return false;

    cmdstr[0] = mode;
    count = 1;

    if (mode & STORE_SI_BIT)     // update value of servoinit
      mod[addr].kind.servo.servoinit = (mode & INIT_SERVO ? (byte) 1 : (byte) 0);

    if (mode & STORE_OUTPUTS) {
      cmdstr[1] = out1;
      cmdstr[2] = out2;
      cmdstr[3] = out3;
      cmdstr[4] = out4;
      count = 5;
    }
    return LdcnSendCmd(addr, EEPROM_CTRL, cmdstr, (byte)count);
  }
  else   // if mode = 0, read in 28 bytes then get status - USE  mode = 0 ONLY for INITIALIZATION!
    return ServoReadEEPROM(addr, mode);
}
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
ServoGetNPoints                  <Ldcn.lib>

SYNTAX: byte ServoGetNPoints (byte addr);

PARAMETER1: <addr>  - module address

KEYWORDS: ServoModuleFunctions

DESCRIPTION: Returns the current number of points in the path buffer
             of a SERVO Drive.
             Note: this data is only valid if the SEND_NPOINTS bit of
             statusitems has been set in the most recently issued
             LdcnDefineStatus() function.

RETURN VALUE: current number of points in the path buffer of a SERVO Drive.
END DESCRIPTION **********************************************************/

/*** BeginHeader ServoGetNPoints */
     byte ServoGetNPoints(byte addr);
/*** EndHeader */

byte ServoGetNPoints(byte addr) {  return mod[addr].kind.servo.npoints; }
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
ServoSetFastPath                 <Ldcn.lib>

SYNTAX: bool ServoSetFastPath (byte addr, bool fast_path);

PARAMETER1: <addr>      - module address
PARAMETER2: <fast_path> - fast path mode bite

KEYWORDS: ServoModuleFunctions

DESCRIPTION: Set a servo drive advanced mode.
             If parameter <fast_path> is false the drive is set in
             slow path mode (30 Hz / 60 Hz - bit 6 of I/O control
             byte is 0), otherwise the drive is set in fast
             path mode (60Hz / 120 Hz).

RETURN VALUE: true on success, false on failure
END DESCRIPTION **********************************************************/

/*** BeginHeader ServoSetFastPath */
     bool ServoSetFastPath(byte addr, bool fast_path);
/*** EndHeader */

bool ServoSetFastPath(byte addr, bool fast_path) {
byte mode;

  mode = fast_path ? FAST_PATH : 0;
  mode |= mod[addr].kind.servo.ioctrl;
  mod[addr].kind.servo.ioctrl = mode;
  return LdcnSendCmd(addr, IO_CTRL, (char *)(&mode), 1);
}
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
ServoResetRelHome                  <Ldcn.lib>

SYNTAX: bool ServoResetRelHome (byte addr);

PARAMETER1: <addr>  - module address

KEYWORDS: ServoModuleFunctions

DESCRIPTION: Extension of the Reset Position (0x1) command.
             The current position will be set to the difference
             between old current position and the home position.

RETURN VALUE: true on success, false on failure
END DESCRIPTION **********************************************************/

/*** BeginHeader ServoResetRelHome */
     bool ServoResetRelHome(byte addr);
/*** EndHeader */

bool ServoResetRelHome(byte addr) {
byte mode;

  mode = REL_HOME;
  return LdcnSendCmd(addr, RESET_POS, (char *)(&mode), 1);
}
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
ServoInitPath                  <Ldcn.lib>

SYNTAX: void ServoInitPath (byte addr);

PARAMETER1: <addr> - module address

KEYWORDS: ServoModuleFunctions

DESCRIPTION: Saves the current position into a variable that is
             used later by ServoAddPathPoints() function to calculate
             the distance between the last added and the new point and
             the relevant direction. Execute this function only once
             before starting to add points into the drive path buffer.

RETURN VALUE: none
END DESCRIPTION **********************************************************/

/*** BeginHeader ServoInitPath */
     void ServoInitPath(byte addr);
/*** EndHeader */

void ServoInitPath(byte addr) {

  LdcnReadStatus(addr, SEND_POS | SEND_PERROR);
  mod[addr].kind.servo.last_ppoint = mod[addr].kind.servo.pos + mod[addr].kind.servo.perror;
}
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
ServoAddPathPoints                  <Ldcn.lib>

SYNTAX: bool ServoAddPathPoints (byte addr, int npoints,
                                     long *path, bool high_freq);

PARAMETER1: <addr>      - module address
PARAMETER2: <npoints>   - number of points
PARAMETER3: <path>      - points array
PARAMETER4: <high_freq> - frequency type /low, high/

KEYWORDS: ServoModuleFunctions

DESCRIPTION:This function allows the user to add path points into the internal  path
            point buffer of the drive.  Up to 7 path points  may be added at with  a
            single command, and multiple commands may  be issued to load a total  of
            96 path points. Normally,  just one timing mode  is used in a  path, but
            the timing can  be mixed. The  timing mode depends  on two parameters -
            high_freq  and  the  fast  parameter  of ServoSetFastPath() function. If
            high_freq is  true the  points will  be added  with the  higher possible
            frequency determined by the fast parameter - 60 Hz if fast is false  and
            120 Hz if fast is true.

RETURN VALUE: true on success, false on failure
END DESCRIPTION **********************************************************/

/*** BeginHeader ServoAddPathPoints */
     bool ServoAddPathPoints(byte addr, int npoints, long *path, bool high_freq);
/*** EndHeader */

// Add ABSOLUTE points
bool ServoAddPathPoints(byte addr, int npoints, long *path, bool high_freq) {
char cmdstr[16];
long diff;
int i, shift_bits;
bool rev;

  if (npoints > 7) return false;

  shift_bits = (mod[addr].kind.servo.ioctrl & FAST_PATH) ? 3 : 2;
  if (high_freq) shift_bits++;

  for (i = 0; i < npoints; i++) {
    diff = path[ i] - mod[addr].kind.servo.last_ppoint;

    if (diff < 0) { rev = 0x01;  diff = -diff;
    } else          rev = 0x00;

    if (diff >> ( 16 - shift_bits)) return false;
    diff <<= shift_bits;
    diff  |= rev;
    if (!high_freq) diff |= 0x02;

    *( (int *)(cmdstr + 2*i) ) = (int)diff;
    mod[addr].kind.servo.last_ppoint = path[i];
  }
  return LdcnSendCmd(addr, ADD_PATHPOINT, cmdstr, (byte)(npoints*2));
}
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
ServoStartPathMode                  <Ldcn.lib>

SYNTAX: bool ServoStartPathMode (byte groupaddr);

PARAMETER1: <groupaddr> - group address

KEYWORDS: ServoModuleFunctions

DESCRIPTION: To actually start execution of the path in the path
             point buffer, an Add Path Points (0xD) command is issued
             with no path point data included. The groupaddr parameter
             could be a valid group address (to start several
             controllers simultaneously) or any individual address.

RETURN VALUE: true on success, false on failure
END DESCRIPTION **********************************************************/

/*** BeginHeader ServoStartPathMode */
     bool ServoStartPathMode(byte groupaddr);
/*** EndHeader */

bool ServoStartPathMode(byte groupaddr) {
   return LdcnSendCmd(groupaddr, ADD_PATHPOINT, NULL, 0);
}


//---------------------------------------------------------------------------
// S T E P P E R  F U N C T I N S -------------------------------------------
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
StepperFunctions                 <Ldcn.lib>

unsigned int StepsPerSec2StepTime(double StepsPerSecond, int SpeedFactor);
double StepTime2StepsPerSec(unsigned int InitialTimerCount, int SpeedFactor);
double StepsPerSec2mSecPerStep(double StepsPerSecond);
double mSecPerStep2StepsPerSec(double mSecPerStep);
double MinStepPeriod(int SpeedFactor);
double MaxStepPeriod(int SpeedFactor);

bool StepGetStat(byte addr);
long StepGetPos(byte addr);
byte StepGetAD(byte addr);
unsigned int StepGetStepTime(byte addr);
byte StepGetInbyte(byte addr);
long StepGetHome(byte addr);
long StepGetCmdPos(byte addr);
byte StepGetCmdSpeed(byte addr);
byte StepGetCmdAcc(byte addr);
unsigned int StepGetCmdST(byte addr);
double StepGetStepPeriod(byte addr);
byte StepGetMinSpeed(byte addr);
byte StepGetOutputs(byte addr);
byte StepGetCtrlMode(byte addr);
byte StepGetMvMode(byte addr);
byte StepGetRunCurrent(byte addr);
byte StepGetHoldCurrent(byte addr);
byte StepGetEmAcc(byte addr);
byte StepGetThermLimit(byte addr);
byte StepGetHomeCtrl(byte addr);
byte StepGetStopCtrl(byte addr);
bool StepSetParam(byte addr, byte mode, byte minspeed, byte runcur, byte holdcur, byte thermlim, byte em_acc);
bool StepLoadTraj(byte addr, byte mode, long pos, byte vel, byte acc, unsigned int steptime);
bool StepLoadUnprofiledTraj(byte addr, byte mode, long pos, double step_period);
bool StepResetPos(byte addr);
bool StepStopMotor(byte addr, byte mode);
bool StepSetOutputs(byte addr, byte outbyte);
bool StepSetHoming(byte addr, byte mode);
byte StepGetIObyte(byte addr);
END DESCRIPTION **********************************************************/


/* START FUNCTION DESCRIPTION ********************************************
StepsPerSec2StepTime                          <Ldcn.lib>

SYNTAX: unsigned int StepsPerSec2StepTime (double StepsPerSecond,
                                               int SpeedFactor);
PARAMETER1: <StepsPerSecond> - steps per second
PARAMETER2: <SpeedFactor>    - Speed Factor - step time parameter

KEYWORDS: StepperFunctions

DESCRIPTION: Converts a velocity value in steps per second into
             StepTime parameter required by LoadTrajectory command.
             This conversion depends on the step timer speed that is
             defined by <SpeedFactor> parameter:
                SF    Step_Timer_Speed
                0          625,000 Hz
                1        1,250,000 Hz
                2        2,500,000 Hz
                3        5,000,000 Hz

RETURN VALUE:  Step time
END DESCRIPTION **********************************************************/

/*** BeginHeader StepsPerSec2StepTime */
     unsigned int StepsPerSec2StepTime(double StepsPerSecond, int SpeedFactor);
/*** EndHeader */

unsigned int StepsPerSec2StepTime(double StepsPerSecond, int SpeedFactor) {
long res;

  if (StepsPerSecond == 0.) res = 65452; else
  switch (SpeedFactor) {
    case 0: res = (long)(65536 - ( 625000 / StepsPerSecond) +  2.5); break;
    case 1: res = (long)(65536 - (1250000 / StepsPerSecond) +  4.5); break;
    case 2: res = (long)(65536 - (2500000 / StepsPerSecond) +  8.5); break;
    case 3: res = (long)(65536 - (5000000 / StepsPerSecond) + 16.5); break;
  }
  if (res < 1) res = 1; else
  if (res > 65452) res = 65452;
  return (unsigned int) res;
}
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
StepTime2StepsPerSec                    <Ldcn.lib>

SYNTAX: double StepTime2StepsPerSec (unsigned int InitialTimerCount,
                                     int SpeedFactor);

PARAMETER1: <InitialTimerCount> - Step time
PARAMETER2: <SpeedFactor>       - Speed Factor - step time parameter

KEYWORDS: StepperFunctions

DESCRIPTION: Converts a velocity value in StepTime parameter required
             by LoadTrajectory command into steps per second.

RETURN VALUE: steps per second
END DESCRIPTION **********************************************************/

/*** BeginHeader StepTime2StepsPerSec */
     double StepTime2StepsPerSec(unsigned int InitialTimerCount, int SpeedFactor);
/*** EndHeader */

double StepTime2StepsPerSec(unsigned int InitialTimerCount, int SpeedFactor) {
  switch (SpeedFactor) {
    case 0: return  625000. / (65536 +  2 - InitialTimerCount);
    case 1: return 1250000. / (65536 +  4 - InitialTimerCount);
    case 2: return 2500000. / (65536 +  8 - InitialTimerCount);
    case 3: return 5000000. / (65536 + 16 - InitialTimerCount);
  }
  return 0;
}
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
StepsPerSec2mSecPerStep                    <Ldcn.lib>

SYNTAX: double StepsPerSec2mSecPerStep (double StepsPerSecond);

PARAMETER1: <StepsPerSecond> -  Steps Per Second

KEYWORDS: StepperFunctions

DESCRIPTION: Converts a velocity in steps per second into steps per microsecond.

RETURN VALUE: steps per microsecond
END DESCRIPTION **********************************************************/

/*** BeginHeader StepsPerSec2mSecPerStep */
     double StepsPerSec2mSecPerStep(double StepsPerSecond);
/*** EndHeader */

double StepsPerSec2mSecPerStep(double StepsPerSecond) {
  return (1000000. / StepsPerSecond);
}
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
mSecPerStep2StepsPerSec                    <Ldcn.lib>

SYNTAX: double mSecPerStep2StepsPerSec (double StepsPerSecond);

PARAMETER1: <StepsPerSecond> -  Steps Per Second

KEYWORDS: StepperFunctions

DESCRIPTION: Converts a velocity in steps per microsecond
             into steps per second.

RETURN VALUE: steps per microsecond
END DESCRIPTION **********************************************************/

/*** BeginHeader mSecPerStep2StepsPerSec */
     double mSecPerStep2StepsPerSec(double mSecPerStep);
/*** EndHeader */

double mSecPerStep2StepsPerSec(double mSecPerStep) {
  return  1000000. / mSecPerStep;
}
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
MaxStepPeriod                    <Ldcn.lib>

SYNTAX: double MaxStepPeriod (int SpeedFactor);

PARAMETER1: <SpeedFactor> - Speed Factor

KEYWORDS: StepperFunctions

DESCRIPTION: Calculates the maximum Step Period in microseconds

RETURN VALUE: the maximum Step Period in microseconds
END DESCRIPTION **********************************************************/

/*** BeginHeader MaxStepPeriod */
     double MaxStepPeriod(int SpeedFactor);
/*** EndHeader */

double MaxStepPeriod(int SpeedFactor) {
  return StepsPerSec2mSecPerStep(StepTime2StepsPerSec(65452, SpeedFactor));
}
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
MinStepPeriod                    <Ldcn.lib>

SYNTAX: double MinStepPeriod (int SpeedFactor);

PARAMETER1: <SpeedFactor> - Speed Factor

KEYWORDS: StepperFunctions

DESCRIPTION: Calculates the minimum Step Period in microseconds

RETURN VALUE: the minimum Step Period in microseconds
END DESCRIPTION **********************************************************/

/*** BeginHeader MinStepPeriod */
     double MinStepPeriod(int SpeedFactor);
/*** EndHeader */

double MinStepPeriod(int SpeedFactor) {
  return StepsPerSec2mSecPerStep(StepTime2StepsPerSec(1, SpeedFactor));
}
//---------------------------------------------------------------------------


//------------------ Initializes STEPMOD structure ---------------------------
/*** BeginHeader StepNewMod */
void StepNewMod(byte addr);
/*** EndHeader */

void StepNewMod(byte addr) {
  mod[addr].kind.step.pos = 0;
  mod[addr].kind.step.ad = 0;
  mod[addr].kind.step.st = 0;
  mod[addr].kind.step.inbyte = 0;
  mod[addr].kind.step.home = 0;
  mod[addr].kind.step.cmdpos = 0;
  mod[addr].kind.step.cmdspeed = 1;
  mod[addr].kind.step.cmdacc = 1;
  mod[addr].kind.step.cmdst = 1;
  mod[addr].kind.step.st_period = MinStepPeriod(0);
  mod[addr].kind.step.min_speed = 1;
  mod[addr].kind.step.outbyte = 0;
  mod[addr].kind.step.homectrl = HOME_STOP_ABRUPT;
  mod[addr].kind.step.ctrlmode = SPEED_1X | MOFF_STOP;
  mod[addr].kind.step.stopctrl = 0;
  mod[addr].kind.step.run_pwm = 0;
  mod[addr].kind.step.hold_pwm = 0;
  mod[addr].kind.step.therm_limit = 0;
  mod[addr].kind.step.move_mode = 0;
  mod[addr].kind.step.emergency_acc = 255;
  mod[addr].kind.step.stat_io = 0;
}


//-------------------------- STEPPER functions ------------------------------

/* START FUNCTION DESCRIPTION ********************************************
StepGetStat                  <Ldcn.lib>

SYNTAX: bool StepGetStat (byte addr);

PARAMETER1: <addr> - module address

KEYWORDS: StepperFunctions

DESCRIPTION: Receives the status data of a specified STEP device according
             to the last defined by LdcnDefineStatus() status items.

RETURN VALUE: true - on success, false on failure
END DESCRIPTION **********************************************************/

/*** BeginHeader StepGetStat */
     bool StepGetStat(byte addr);
/*** EndHeader */

bool StepGetStat(byte addr) {
  int numbytes, numrcvd;
  int i, bytecount;
  byte cksum;
  byte inbuf[20];

  if (addr & 0x80) return false;              // punt if addr is a group address
  if (mod[addr].modtype != STEPMODTYPE) return false;

// Find number of bytes to read:
  numbytes = 2;       // start with stat & cksum
  if ( (mod[addr].statusitems) & SEND_POS )	numbytes +=4;
  if ( (mod[addr].statusitems) & SEND_AD ) 	numbytes +=1;
  if ( (mod[addr].statusitems) & SEND_ST ) 	numbytes +=2;
  if ( (mod[addr].statusitems) & SEND_INBYTE )  numbytes +=1;
  if ( (mod[addr].statusitems) & SEND_HOME )	numbytes +=4;
  if ( (mod[addr].statusitems) & SEND_ID ) 	numbytes +=2;
  if ( (mod[addr].statusitems) & SEND_OUT ) 	numbytes +=1;
  numrcvd = SioGetChars(ComPort, (char *)inbuf, numbytes);

// Verify enough data was read
  if (numrcvd != numbytes)  return false;

// Verify checksum:
  cksum = 0;
  for (i=0; i<numbytes-1; i++)     cksum = (byte)(cksum + inbuf[i]);
  if (cksum != inbuf[numbytes-1])  return false;

// Verify command was received intact before updating status data
  mod[addr].stat = inbuf[0];
  if (mod[addr].stat & CKSUM_ERROR)  return false;

// Finally, fill in status data
  bytecount = 1;
  if ( (mod[addr].statusitems) & SEND_POS ) {
    mod[addr].kind.step.pos = *( (long *)(inbuf + bytecount) );
    bytecount +=4;
  }
  if ( (mod[addr].statusitems) & SEND_AD ) {
    mod[addr].kind.step.ad = inbuf[bytecount];
    bytecount +=1;
  }
  if ( (mod[addr].statusitems) & SEND_ST ) {
    mod[addr].kind.step.st = *( (unsigned int *)(inbuf + bytecount) );
    bytecount +=2;
  }
  if ( (mod[addr].statusitems) & SEND_INBYTE ) {
    mod[addr].kind.step.inbyte = inbuf[bytecount];
    bytecount +=1;
  }
  if ( (mod[addr].statusitems) & SEND_HOME ) {
    mod[addr].kind.step.home = *( (unsigned long *)(inbuf + bytecount) );
    bytecount +=4;
  }
  if ( (mod[addr].statusitems) & SEND_ID ) {
    mod[addr].modtype = inbuf[bytecount];
    mod[addr].modver = inbuf[bytecount+1];
    bytecount +=2;
  }

  if ( (mod[addr].statusitems) & SEND_OUT ) {
    mod[addr].kind.step.stat_io = inbuf[bytecount];
//    bytecount +=1;
  }

  return true;
}
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
StepGetPos                  <Ldcn.lib>

SYNTAX: long StepGetPos (byte addr);

PARAMETER1: <addr> - module address

KEYWORDS: StepperFunctions

DESCRIPTION: Returns the current motor position of a STEP module
             Note: this data is valid only if the SEND_POS bit has been
             set in the most recently issued LdcnDefineStatus () command

RETURN VALUE: current motor position of a STEP module

END DESCRIPTION **********************************************************/

/*** BeginHeader StepGetPos */
     long StepGetPos(byte addr);
/*** EndHeader */

long StepGetPos(byte addr) {  return mod[addr].kind.step.pos; }
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
StepGetAD                  <Ldcn.lib>

SYNTAX: byte StepGetAD (byte addr);

PARAMETER1: <addr> - module address

KEYWORDS: StepperFunctions

DESCRIPTION: Returns the current A/D value of a STEP module.
             Note: this data is only valid if the SEND_AD bit has been
             set in the most recently issued LdcnDefineStatus() command.

RETURN VALUE: current A/D value of a STEP module
END DESCRIPTION **********************************************************/

/*** BeginHeader StepGetAD */
     byte StepGetAD(byte addr);
/*** EndHeader */

byte StepGetAD(byte addr) { return mod[addr].kind.step.ad; }
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
StepGetStepTime                          <Ldcn.lib>

SYNTAX: unsigned int StepGetStepTime (byte addr);

PARAMETER1: <addr> - module address

KEYWORDS: StepperFunctions

DESCRIPTION: Returns the most recently used step time for a STEP module.
             Note: this data is only valid if the SEND_ST bit has been
             set in the most recently issued LdcnDefineStat() command.

RETURN VALUE: used step time for a STEP module
END DESCRIPTION **********************************************************/

/*** BeginHeader StepGetStepTime */
     unsigned int StepGetStepTime(byte addr);
/*** EndHeader */

unsigned int StepGetStepTime(byte addr) {  return mod[addr].kind.step.st; }
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
StepGetInbyte                  <Ldcn.lib>

SYNTAX: byte StepGetInbyte (byte addr);

PARAMETER1: <addr> - module address

KEYWORDS: StepperFunctions

DESCRIPTION: Returns the input byte value of a STEP module.
             Note: this data is only valid if the SEND_INBYTE bit has been
             set in the most recently issued LdcnDefineStat() command.

RETURN VALUE: input byte value of a STEP module
END DESCRIPTION **********************************************************/

/*** BeginHeader StepGetInbyte */
     byte StepGetInbyte(byte addr);
/*** EndHeader */

byte StepGetInbyte(byte addr) {  return mod[addr].kind.step.inbyte; }
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
StepGetHome                  <Ldcn.lib>

SYNTAX: long StepGetHome (byte addr);

PARAMETER1: <addr> - module address

KEYWORDS: StepperFunctions

DESCRIPTION: Returns the current motor home position of a STEP module.
             Note: this data is only valid if the SEND_HOME bit has been
             set in the most recently issued LdcnDefineStat() command.

RETURN VALUE: current home position of a STEP module
END DESCRIPTION **********************************************************/

/*** BeginHeader StepGetHome */
     long StepGetHome(byte addr);
/*** EndHeader */

long StepGetHome(byte addr) {  return mod[addr].kind.step.home; }
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
StepGetCmdPos                  <Ldcn.lib>

SYNTAX: long StepGetCmdPos (byte addr);

PARAMETER1: <addr> - module address

KEYWORDS: StepperFunctions

DESCRIPTION: Returns the most recently used command position for a STEP module.

RETURN VALUE: command position for a STEP module
END DESCRIPTION **********************************************************/

/*** BeginHeader StepGetCmdPos */
     long StepGetCmdPos(byte addr);
/*** EndHeader */

long StepGetCmdPos(byte addr) {  return mod[addr].kind.step.cmdpos; }
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
StepGetCmdSpeed                  <Ldcn.lib>

SYNTAX: byte StepGetCmdSpeed (byte addr);

PARAMETER1: <addr> - module address

KEYWORDS: StepperFunctions

DESCRIPTION: Returns the most recently used command speed for a STEP module.

RETURN VALUE: Last used speed for a STEP module
END DESCRIPTION **********************************************************/

/*** BeginHeader  StepGetCmdSpeed */
     byte StepGetCmdSpeed(byte addr);
/*** EndHeader */

byte StepGetCmdSpeed(byte addr) {  return mod[addr].kind.step.cmdspeed; }
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
StepGetCmdAcc                  <Ldcn.lib>

SYNTAX: byte StepGetCmdAcc (byte addr);

PARAMETER1: <addr> - module address

KEYWORDS: StepperFunctions

DESCRIPTION: Returns the most recently used command acceleration for a STEP module.

RETURN VALUE: command acceleration for a STEP module
END DESCRIPTION **********************************************************/

/*** BeginHeader StepGetCmdAcc */
     byte StepGetCmdAcc(byte addr);
/*** EndHeader */

byte StepGetCmdAcc(byte addr) {  return mod[addr].kind.step.cmdacc; }
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
StepGetCmdST                          <Ldcn.lib>

SYNTAX: unsigned int StepGetCmdST (byte addr);

PARAMETER1: <addr> - module address

KEYWORDS: StepperFunctions

DESCRIPTION: Returns the most recently used command step time for a STEP module.

RETURN VALUE: command step time for a STEP module.
END DESCRIPTION **********************************************************/

/*** BeginHeader StepGetCmdST */
     unsigned int StepGetCmdST(byte addr);
/*** EndHeader */

unsigned int StepGetCmdST(byte addr) {  return mod[addr].kind.step.cmdst; }
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
StepGetStepPeriod                    <Ldcn.lib>

SYNTAX: double StepGetStepPeriod (byte addr);

PARAMETER1: <addr> - module address

KEYWORDS: StepperFunctions

DESCRIPTION: Returns the most recently used step period in milliseconds
             by StepLoadUnprofiledTraj() function for a STEPPER drive.

RETURN VALUE: used step period
END DESCRIPTION **********************************************************/

/*** BeginHeader StepGetStepPeriod */
     double StepGetStepPeriod(byte addr);
/*** EndHeader */

double StepGetStepPeriod(byte addr) {  return mod[addr].kind.step.st_period; }
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
StepGetMinSpeed                  <Ldcn.lib>

SYNTAX: byte StepGetMinSpeed (byte addr);

PARAMETER1: <addr> - module address

KEYWORDS: StepperFunctions

DESCRIPTION: Returns the most recently used commanded minimal
             velocity for a STEP module.

RETURN VALUE: minimal velocity for a STEP module
END DESCRIPTION **********************************************************/

/*** BeginHeader StepGetMinSpeed */
     byte StepGetMinSpeed(byte addr);
/*** EndHeader */

byte StepGetMinSpeed(byte addr) {  return mod[addr].kind.step.min_speed; }
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
StepGetOutputs                  <Ldcn.lib>

SYNTAX: byte StepGetOutputs (byte addr);

PARAMETER1: <addr> - module address

KEYWORDS: StepperFunctions

DESCRIPTION: Returns the most recently set state of
             an output byte for a STEPPER drive.

RETURN VALUE: output byte for a STEPPER drive
END DESCRIPTION **********************************************************/

/*** BeginHeader StepGetOutputs */
     byte StepGetOutputs(byte addr);
/*** EndHeader */

byte StepGetOutputs(byte addr) {  return mod[addr].kind.step.outbyte; }
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
StepGetCtrlMode                  <Ldcn.lib>

SYNTAX: byte StepGetCtrlMode (byte addr);

PARAMETER1: <addr> - module address

KEYWORDS: StepperFunctions

DESCRIPTION: Returns the mode control byte of the most recently
             issued function StepSetParam() for a STEPPER drive.

RETURN VALUE: mode control byte for a STEPPER drive
END DESCRIPTION **********************************************************/

/*** BeginHeader StepGetCtrlMode */
     byte StepGetCtrlMode(byte addr);
/*** EndHeader */

byte StepGetCtrlMode(byte addr) {  return mod[addr].kind.step.ctrlmode; }
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
StepGetMvMode                  <Ldcn.lib>

SYNTAX: byte StepGetMvMode (byte addr);

PARAMETER1: <addr> - module address

KEYWORDS: StepperFunctions

DESCRIPTION: Returns the most recently used motion mode control byte
             by LoadTrajectory command for a STEPPER drive.

RETURN VALUE: last motion mode for a STEPPER drive
END DESCRIPTION **********************************************************/

/*** BeginHeader StepGetMvMode */
     byte StepGetMvMode(byte addr);
/*** EndHeader */

byte StepGetMvMode(byte addr) {  return mod[addr].kind.step.move_mode; }
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
StepGetRunCurrent                  <Ldcn.lib>

SYNTAX: byte StepGetRunCurrent (byte addr);

PARAMETER1: <addr> - module address

KEYWORDS: StepperFunctions

DESCRIPTION: Returns the most recently used commanded
             running current for a STEP module.

RETURN VALUE: last used commanded running current for a STEP module
END DESCRIPTION **********************************************************/

/*** BeginHeader StepGetRunCurrent */
     byte StepGetRunCurrent(byte addr);
/*** EndHeader */

byte StepGetRunCurrent(byte addr) {  return mod[addr].kind.step.run_pwm; }
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
StepGetHoldCurrent                  <Ldcn.lib>

SYNTAX: byte StepGetHoldCurrent (byte addr);

PARAMETER1: <addr> - module address

KEYWORDS: StepperFunctions

DESCRIPTION: Returns the most recently used commanded
             holding current for a STEP module.

RETURN VALUE: last used commanded holding current for a STEP module.
END DESCRIPTION **********************************************************/

/*** BeginHeader StepGetHoldCurrent */
     byte StepGetHoldCurrent(byte addr);
/*** EndHeader */

byte StepGetHoldCurrent(byte addr) {  return mod[addr].kind.step.hold_pwm; }
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
StepGetThermLimit                  <Ldcn.lib>

SYNTAX: byte StepGetThermLimit (byte addr);

PARAMETER1: <addr> - module address

KEYWORDS: StepperFunctions

DESCRIPTION: Returns the most recently used commanded thermal limit for a STEP module.

RETURN VALUE:  last used commanded thermal limit for a STEP module.
END DESCRIPTION **********************************************************/

/*** BeginHeader StepGetThermLimit */
     byte StepGetThermLimit(byte addr);
/*** EndHeader */

byte StepGetThermLimit(byte addr) {  return mod[addr].kind.step.therm_limit; }
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
StepGetHomeCtrl                  <Ldcn.lib>

SYNTAX: byte StepGetHomeCtrl (byte addr);

PARAMETER1: <addr> - module address

KEYWORDS: StepperFunctions

DESCRIPTION: Returns the mode control byte of the most recently
             issued function StepSetHoming() for a STEP module.

RETURN VALUE:  mode control byte for last function StepSetHoming()
END DESCRIPTION **********************************************************/

/*** BeginHeader StepGetHomeCtrl */
     byte StepGetHomeCtrl(byte addr);
/*** EndHeader */

byte StepGetHomeCtrl(byte addr) {  return mod[addr].kind.step.homectrl; }
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
StepGetStopCtrl                  <Ldcn.lib>

SYNTAX: byte StepGetStopCtrl (byte addr);

PARAMETER1: <addr> - module address

KEYWORDS: StepperFunctions

DESCRIPTION: Returns the stop control byte of the most recently
             issued function StepStopMotor() for a STEP module.

RETURN VALUE: stop control byte for last function StepStopMotor()
END DESCRIPTION **********************************************************/

/*** BeginHeader StepGetStopCtrl */
     byte StepGetStopCtrl(byte addr);
/*** EndHeader */

byte StepGetStopCtrl(byte addr) { return mod[addr].kind.step.stopctrl; }
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
StepGetEmAcc                  <Ldcn.lib>

SYNTAX: byte StepGetEmAcc(byte addr);

PARAMETER1: <addr> - module address

KEYWORDS: StepperFunctions

RETURN VALUE: Returns the most recently used commanded
              emergency acceleratin for a STEP module.
END DESCRIPTION **********************************************************/

/*** BeginHeader StepGetEmAcc */
     byte StepGetEmAcc(byte addr);
/*** EndHeader */

byte StepGetEmAcc(byte addr)  {return mod[addr].kind.step.emergency_acc; }
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
StepSetParam                  <Ldcn.lib>

SYNTAX: bool StepSetParam (byte addr, byte mode, byte minspeed, byte runcur,
                           byte holdcur, byte thermlim, byte em_acc);

PARAMETER1: <addr>     - module address
PARAMETER2: <mode>     - control byte
PARAMETER3: <minspeed> - minimum velocity
PARAMETER4: <runcur>   - running current
PARAMETER5: <holdcur>  - holding current
PARAMETER6: <thermlim> - thermal limit
PARAMETER7: <em_acc>   - emergency acceleration

KEYWORDS: StepperFunctions

DESCRIPTION: Sets motion parameters for a STEP module. Mode is the set
             parameters control byte and should be set to the bitwise OR
             of the set parameters control bits. Also sets minimal velocity,
             running current, holding current, and thermal limit.

RETURN VALUE: true on success, false on failure
END DESCRIPTION **********************************************************/

/*** BeginHeader StepSetParam */
     bool StepSetParam(byte addr, byte mode, byte minspeed, byte runcur, byte holdcur, byte thermlim, byte em_acc);
/*** EndHeader */

bool StepSetParam(byte addr, byte mode, byte minspeed, byte runcur, byte holdcur, byte thermlim, byte em_acc) {
  char cmdstr[6];

  mod[addr].kind.step.ctrlmode = mode;
  mod[addr].kind.step.min_speed = minspeed;
  mod[addr].kind.step.run_pwm = runcur;
  mod[addr].kind.step.hold_pwm = holdcur;
  mod[addr].kind.step.therm_limit = thermlim;
  mod[addr].kind.step.emergency_acc = em_acc;

  cmdstr[0] = mode;
  cmdstr[1] = minspeed;
  cmdstr[2] = runcur;
  cmdstr[3] = holdcur;
  cmdstr[4] = thermlim;
  cmdstr[5] = em_acc;

  return LdcnSendCmd(addr, SET_PARAM, cmdstr, 6);
}
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
StepLoadTraj                  <Ldcn.lib>

SYNTAX: bool StepLoadTraj (byte addr, byte mode, long pos,
                           byte vel, byte acc, unsigned int steptime);

PARAMETER1: <addr>     - module address
PARAMETER2: <mode>     - motion mode
PARAMETER3: <pos>      - position
PARAMETER4: <vel>      - velocity
PARAMETER5: <acc>      - acceleration
PARAMETER6: <steptime> - step time

KEYWORDS: StepperFunctions

DESCRIPTION: Loads motion trajectory information for a STEPPER drive by
             executing LoadTrajectory command. Mode is the load trajectory
             control byte, and should be set to bitwise OR of the trajectory
             control byte bits. Note that if the START_NOW bit is set, the
             motion will begin immediately; if it is not set, the motion will
             be started when StartMotiont command is executed.

RETURN VALUE: true on success, false on failure
END DESCRIPTION **********************************************************/

/*** BeginHeader StepLoadTraj */
     bool StepLoadTraj(byte addr, byte mode, long pos, byte vel, byte acc, unsigned int steptime);
/*** EndHeader */

bool StepLoadTraj(byte addr, byte mode, long pos, byte vel, byte acc, unsigned int steptime) {
  char cmdstr[16];
  byte nearspeed;
  int count;

  if (vel < 1 ) vel = 1;
  if (acc < 1 ) acc = 1;

  switch (mod[addr].kind.step.ctrlmode & 0x03) {
    case SPEED_1X: nearspeed = (byte)( 625000 / (65536 +  2 - steptime) /  25); break;
    case SPEED_2X: nearspeed = (byte)(1250000 / (65536 +  4 - steptime) /  50); break;
    case SPEED_4X: nearspeed = (byte)(2500000 / (65536 +  8 - steptime) / 100); break;
    case SPEED_8X: nearspeed = (byte)(5000000 / (65536 + 16 - steptime) / 200); break;
  }

  nearspeed = (byte)(nearspeed + 0.5);

  count = 0;
  *( (byte *)(cmdstr + count) ) = mode;  count += 1;
  if (mode & LOAD_POS) {
    mod[addr].kind.step.cmdpos = pos;
    *( (long *)(cmdstr + count) ) = pos;
    count += 4;
  }
  if (mode & LOAD_SPEED) {
    mod[addr].kind.step.cmdspeed = vel;
    *( (byte *)(cmdstr + count) ) = vel;
    count += 1;
  }
  if (mode & LOAD_ACC) {
    mod[addr].kind.step.cmdacc = acc;
    *( (byte *)(cmdstr + count) ) = acc;
    count += 1;
  }
  if (mode & LOAD_ST) {
    mod[addr].kind.step.cmdst = steptime;
    *( (int *)(cmdstr + count) ) = steptime;
    count += 2;
    *( (byte *)(cmdstr + count) ) = nearspeed;
    count += 1;
  }

  mod[addr].kind.step.move_mode = mode;
  return LdcnSendCmd(addr, LOAD_TRAJ, cmdstr, (byte)count);
}
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
StepLoadUnprofiledTraj                  <Ldcn.lib>

SYNTAX: bool StepLoadUnprofiledTraj (byte addr, byte mode,
                                     long pos, double step_period);

PARAMETER1: <addr>        - module address
PARAMETER2: <mode>        - motion mode control byte
PARAMETER3: <pos>         - position
PARAMETER4: <step_period> - step period

KEYWORDS: StepperFunctions

DESCRIPTION: This function works similarly to StepLoadTraj()  for loading
             only unprofiled motion parameters. To avoid the inconvenience
             steptime parameter StepLoadUnprofiledTraj() uses
             <step_period> - the time for a single step in microseconds.

RETURN VALUE: true on success, false on failure
END DESCRIPTION **********************************************************/

/*** BeginHeader StepLoadUnprofiledTraj */
     bool StepLoadUnprofiledTraj(byte addr, byte mode, long pos, double step_period);
/*** EndHeader */

bool StepLoadUnprofiledTraj(byte addr, byte mode, long pos, double step_period) {
  byte SpeedFactor, param_mode;
  unsigned int steptime;

  param_mode = StepGetCtrlMode(addr);
  SpeedFactor = 0;
  switch (param_mode & 0x03) {
    case SPEED_8X: SpeedFactor = 3; break;
    case SPEED_4X: SpeedFactor = 2; break;
    case SPEED_2X: SpeedFactor = 1; break;
    case SPEED_1X: SpeedFactor = 0; break;
  }

  if ((step_period < MaxStepPeriod(SpeedFactor)) || (step_period > MinStepPeriod(SpeedFactor))) return 0;
  steptime = StepsPerSec2StepTime(mSecPerStep2StepsPerSec(step_period), SpeedFactor);
  mode = mode & ~(LOAD_SPEED | LOAD_ACC);
  mod[addr].kind.step.st_period = step_period;
  return StepLoadTraj(addr, mode, pos, 0, 0, steptime);
}
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
StepResetPos                  <Ldcn.lib>

SYNTAX: bool StepResetPos (byte addr);

PARAMETER1: <addr> - module address

KEYWORDS: StepperFunctions

DESCRIPTION: Resets the current position to 0.

RETURN VALUE: true on success, false on failure
END DESCRIPTION **********************************************************/

/*** BeginHeader StepResetPos */
     bool StepResetPos(byte addr);
/*** EndHeader */

bool StepResetPos(byte addr) {  return LdcnSendCmd(addr, RESET_POS, NULL, 0); }
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
StepStopMotor                  <Ldcn.lib>

SYNTAX: bool StepStopMotor (byte addr, byte mode);

PARAMETER1: <addr> - module address
PARAMETER2: <mode> - stop mode control byte

KEYWORDS: StepperFunctions

DESCRIPTION: Stops a motor in the manner specified by mode.
             Mode is the stop control byte, and should be set
             to the bitwise OR of the stop control bits.

RETURN VALUE: true on success, false on failure
END DESCRIPTION **********************************************************/

/*** BeginHeader StepStopMotor */
     bool StepStopMotor(byte addr, byte mode);
/*** EndHeader */

bool StepStopMotor(byte addr, byte mode) {
  mod[addr].kind.step.stopctrl = mode;
  return LdcnSendCmd(addr, STOP_MOTOR, (char *)(&mode), 1);
}
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
StepSetOutputs                  <Ldcn.lib>

SYNTAX: bool StepSetOutputs (byte addr, byte outbyte);

PARAMETER1: <addr>    - module address
PARAMETER2: <outbyte> - set value

KEYWORDS: StepperFunctions

DESCRIPTION: Immediately sets the values for the output bits.

RETURN VALUE: true on success, false on failure
END DESCRIPTION **********************************************************/

/*** BeginHeader StepSetOutputs */
     bool StepSetOutputs(byte addr, byte outbyte);
/*** EndHeader */

bool StepSetOutputs(byte addr, byte outbyte) {
  mod[addr].kind.step.outbyte = outbyte;
  return LdcnSendCmd(addr, SET_OUTPUTS, (char *)(&outbyte), 1);
}
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
StepSetHoming                  <Ldcn.lib>

SYNTAX: bool StepSetHoming (byte addr, byte mode);

PARAMETER1: <addr> - module address
PARAMETER2: <mode> - homing control byte

KEYWORDS: StepperFunctions

DESCRIPTION: Starts the homing for STEP module. Mode is the homing
             control byte and should be set to the bitwise OR of the
             homing control bits. This command sets the homing conditions,
             but does not start any motion. The HOME_IN_PROG bit of the
             status byte should be monitored to detect when the home
             position has been captured.

RETURN VALUE: true on success, false on failure
END DESCRIPTION **********************************************************/

/*** BeginHeader StepSetHoming */
     bool StepSetHoming(byte addr, byte mode);
/*** EndHeader */

bool StepSetHoming(byte addr, byte mode) {
  mod[addr].kind.step.homectrl = mode;
  return LdcnSendCmd(addr, SET_HOMING, (char *)(&mode), 1);
}
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
StepGetIObyte                  <Ldcn.lib>

SYNTAX: byte StepGetIObyte (byte addr);

PARAMETER1: <addr> - module address

KEYWORDS: StepperFunctions

DESCRIPTION: Returns a byte containing the current state of all
             IO ports of a STEPPER drive: Bit 0 - IN 0, bit 1 - IN 1,
             bit 2 - IN 2, bit 3 - OUT 0  bit 7 - OUT 4
             Note: this data is only valid if the SEND_OUT bit of statusitems
             has been set in the most recently issued LdcnDefineStat() function.

RETURN VALUE: byte containing the current state of all IO ports
END DESCRIPTION **********************************************************/

/*** BeginHeader StepGetIObyte */
     byte StepGetIObyte(byte addr);
/*** EndHeader */

byte StepGetIObyte(byte addr)  {
  return mod[addr].kind.step.stat_io;
}


//---------------------------------------------------------------------------
// I O  N O D E  F U N C T I O N S ------------------------------------------
//---------------------------------------------------------------------------


//--------------------- IO Module initialization ---------------------------
/*** BeginHeader IoNewMod */
void IoNewMod(byte addr);
/*** EndHeader */

void IoNewMod(byte addr) {
  mod[addr].kind.io.inbits= 0;
  mod[addr].kind.io.ad1   = 0;
  mod[addr].kind.io.ad2   = 0;
  mod[addr].kind.io.ad3   = 0;
  mod[addr].kind.io.timer = 0;
  mod[addr].kind.io.inbits_s = 0;
  mod[addr].kind.io.timer_s  = 0;
  mod[addr].kind.io.pwm1 = 0;
  mod[addr].kind.io.pwm2 = 0;
  mod[addr].kind.io.bitdir = 0x0FFF;
  mod[addr].kind.io.outbits = 0;
  mod[addr].kind.io.timermode = 0;
}
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
IONodeFunctions                 <Ldcn.lib>

bool IoGetStat(byte addr);
bool IoInBitVal(byte addr, int bitnum);
bool IoInBitSVal(byte addr, int bitnum);
bool IoOutBitVal(byte addr, int bitnum);
bool IoSetOutBit(byte addr, int bitnum);
unsigned int IoGetOutputs(byte addr);
bool IoSetOutputs(byte addr, unsigned int outval);
bool IoClrOutBit(byte addr, int bitnum);
byte IoGetADCVal(byte addr, int channel);
bool IoSetPWMVal(byte addr, byte pwm1, byte pwm2);
bool IoSetSynchOutput(byte addr, int outbits, byte pwm1, byte pwm2);
bool IoSetTimerMode(byte addr, byte tmrmode);
byte IoGetTimerMode(byte addr);
unsigned long IoGetTimerVal(byte addr);
byte IoGetPWMVal(byte addr, int channel);
unsigned long IoGetTimerSVal(byte addr);
bool IOSynchOutput(byte groupaddr);
int IoGetBitDir(byte addr, int bitnum);
int IoBitDirOut(byte addr, int bitnum);
int IoBitDirIn(byte addr, int bitnum);
END DESCRIPTION **********************************************************/

//-------------------------- IO node functions ------------------------------

/* START FUNCTION DESCRIPTION ********************************************
IoGetStat                  <Ldcn.lib>

SYNTAX: bool IoGetStat (byte addr);

PARAMETER1: <addr> - module address

KEYWORDS: IONodeFunctions

DESCRIPTION: Receives the status data of a specified I/O node according
             to the last defined by LdcnDefineStatus () status items.

RETURN VALUE: true on success, false on failure
END DESCRIPTION **********************************************************/

/*** BeginHeader IoGetStat */
     bool IoGetStat(byte addr);
/*** EndHeader */

bool IoGetStat(byte addr) {
  int numbytes, numrcvd;
  int i, bytecount;
  byte cksum;
  byte inbuf[20];

// Find number of bytes to read:
  numbytes = 2;       //start with stat & cksum
  if ( (mod[addr].statusitems) & SEND_INPUTS )   numbytes +=2;
  if ( (mod[addr].statusitems) & SEND_AD1 )      numbytes +=1;
  if ( (mod[addr].statusitems) & SEND_AD2 )      numbytes +=1;
  if ( (mod[addr].statusitems) & SEND_AD3 )      numbytes +=1;
  if ( (mod[addr].statusitems) & SEND_TIMER )    numbytes +=4;
  if ( (mod[addr].statusitems) & SEND_ID )       numbytes +=2;
  if ( (mod[addr].statusitems) & SEND_SYNC_IN )  numbytes +=2;
  if ( (mod[addr].statusitems) & SEND_SYNC_TMR ) numbytes +=4;
  numrcvd = SioGetChars(ComPort, (char *)inbuf, numbytes);

// Verify enough data was read
  if (numrcvd != numbytes) return false;

// Verify checksum:
  cksum = 0;
  for (i=0; i<numbytes-1; i++) cksum = (byte)(cksum + inbuf[i]);
   if (cksum != inbuf[numbytes-1]) return false;

// Verify command was received intact before updating status data
  mod[addr].stat = inbuf[0];
  if (mod[addr].stat & CKSUM_ERROR) return false;

// Finally, fill in status data
  bytecount = 1;
  if ( (mod[addr].statusitems) & SEND_INPUTS )	{
    mod[addr].kind.io.inbits = *( (int *)(inbuf + bytecount) );
    bytecount +=2;
  }
  if ( (mod[addr].statusitems) & SEND_AD1 ) {
    mod[addr].kind.io.ad1 = inbuf[bytecount];
    bytecount +=1;
  }
  if ( (mod[addr].statusitems) & SEND_AD2 ) {
    mod[addr].kind.io.ad2 = inbuf[bytecount];
    bytecount +=1;
  }
  if ( (mod[addr].statusitems) & SEND_AD3 ) {
    mod[addr].kind.io.ad3 = inbuf[bytecount];
    bytecount +=1;
  }
  if ( (mod[addr].statusitems) & SEND_TIMER ) {
    mod[addr].kind.io.timer = *( (unsigned long *)(inbuf + bytecount) );
    bytecount +=4;
  }
  if ( (mod[addr].statusitems) & SEND_ID ) {
    mod[addr].modtype = inbuf[bytecount];
    mod[addr].modver = inbuf[bytecount+1];
    bytecount +=2;
  }
  if ( (mod[addr].statusitems) & SEND_SYNC_IN )	{
    mod[addr].kind.io.inbits_s = *( (int *)(inbuf + bytecount) );
    bytecount +=2;
  }
  if ( (mod[addr].statusitems) & SEND_SYNC_TMR ) {
    mod[addr].kind.io.timer_s = *( (unsigned long *)(inbuf + bytecount) );
    // bytecount +=4;
  }

  return true;
}
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
IoInBitVal                  <Ldcn.lib>

SYNTAX: bool IoInBitVal (byte addr, int bitnum);

PARAMETER1: <addr>   - module address
PARAMETER2: <bitnum> - number of input bit

KEYWORDS: IONodeFunctions

DESCRIPTION: Returns the value of input bit <bitnum> from an I/O node.
             Note: this data is only valid if the SEND_INPUTS bit has been
             set in the most recently issued LdcnDefineStat () command.

RETURN VALUE: value of input bit <bitnum>
END DESCRIPTION **********************************************************/

/*** BeginHeader IoInBitVal */
     bool IoInBitVal(byte addr, int bitnum);
/*** EndHeader */

bool IoInBitVal(byte addr, int bitnum) { return ((mod[addr].kind.io.inbits >> bitnum) & 1); }
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
IoInBitSVal                  <Ldcn.lib>

SYNTAX: bool IoInBitSVal (byte addr, int bitnum);

PARAMETER1: <addr>   - module address
PARAMETER2: <bitnum> - number of input bit

KEYWORDS: IONodeFunctions

DESCRIPTION: Returns the value of a synchronously captured input
             bit from an I/O node.
             Note: this data is only valid if the SEND_SYNCH_IN bit has been
             set in the most recently issued LdcnDefineStat () command.

RETURN VALUE: value of a synchronously captured input bit from an I/O node
END DESCRIPTION **********************************************************/

/*** BeginHeader IoInBitSVal */
     bool IoInBitSVal(byte addr, int bitnum);
/*** EndHeader */

bool IoInBitSVal(byte addr, int bitnum) { return ((mod[addr].kind.io.inbits_s >> bitnum) & 1); }
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
IoOutBitVal                  <Ldcn.lib>

SYNTAX: bool IoOutBitVal (byte addr, int bitnum);

PARAMETER1: <addr>   - module address
PARAMETER2: <bitnum> - number of output bit

KEYWORDS: IONodeFunctions

DESCRIPTION: Returns the most recently set state of an
             output bit <bitnum> of an I/O node.

RETURN VALUE: the last set state of an output bit <bitnum> of an I/O node.
END DESCRIPTION **********************************************************/

/*** BeginHeader IoOutBitVal */
     bool IoOutBitVal(byte addr, int bitnum);
/*** EndHeader */

bool IoOutBitVal(byte addr, int bitnum) { return ((mod[addr].kind.io.outbits >> bitnum) & 1); }
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
IoSetOutBit                  <Ldcn.lib>

SYNTAX: bool IoSetOutBit (byte addr, int bitnum);

PARAMETER1: <addr>   - module address
PARAMETER2: <bitnum> - number of output bit to be set

KEYWORDS: IONodeFunctions

RETURN VALUE: true on success, false on failure
END DESCRIPTION **********************************************************/

/*** BeginHeader IoSetOutBit */
     bool IoSetOutBit(byte addr, int bitnum);
/*** EndHeader */

bool IoSetOutBit(byte addr, int bitnum) {
  if (mod[addr].modver == 1) if (bitnum > 11) return false; else;
  else                       if (bitnum > 6)  return false;

  mod[addr].kind.io.outbits = mod[addr].kind.io.outbits | (int)(1 << bitnum);

  return LdcnSendCmd(addr, SET_OUTPUT, (char *)(&(mod[addr].kind.io.outbits)), 2);
}
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
IoGetOutputs                          <Ldcn.lib>

SYNTAX: unsigned int IoGetOutputs (byte addr);

PARAMETER1: <addr> - module address

KEYWORDS: IONodeFunctions

RETURN VALUE: Returns the most recently set state of an output byte of an I/O node.
END DESCRIPTION **********************************************************/

/*** BeginHeader IoGetOutputs */
     unsigned int IoGetOutputs(byte addr);
/*** EndHeader */

unsigned int IoGetOutputs(byte addr) {
  return ((unsigned int)mod[addr].kind.io.outbits);
}
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
IoSetOutputs                  <Ldcn.lib>

SYNTAX: bool IoSetOutputs (byte addr, unsigned int outval);

PARAMETER1: <addr>   - module address
PARAMETER2: <outval> - output value

KEYWORDS: IONodeFunctions

DESCRIPTION: Immediately sets the values for the output bits.

RETURN VALUE: true on success, false on failure
END DESCRIPTION **********************************************************/

/*** BeginHeader IoSetOutputs */
     bool IoSetOutputs(byte addr, unsigned int outval);
/*** EndHeader */

bool IoSetOutputs(byte addr, unsigned int outval) {
  outval &= (mod[addr].modver == 1 ? 0x0FFF : 0x7F);
  mod[addr].kind.io.outbits = outval;

  return LdcnSendCmd(addr, SET_OUTPUT, (char *)(&(mod[addr].kind.io.outbits)), 2);
}
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
IoClrOutBit                  <Ldcn.lib>

SYNTAX: bool IoClrOutBit (byte addr, int bitnum);

PARAMETER1: <addr>   - module address
PARAMETER2: <bitnum> - bit number to be cleared

KEYWORDS: IONodeFunctions

DESCRIPTION: For module at <addr> clears output bit number <bitnum>

RETURN VALUE: true on success, false on failure
END DESCRIPTION **********************************************************/

/*** BeginHeader IoClrOutBit */
     bool IoClrOutBit(byte addr, int bitnum);
/*** EndHeader */

bool IoClrOutBit(byte addr, int bitnum) {
  mod[addr].kind.io.outbits = mod[addr].kind.io.outbits & (int)(~(1 << bitnum));

  return LdcnSendCmd(addr, SET_OUTPUT, (char *)(&(mod[addr].kind.io.outbits)), 2);
}
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
IoGetADCVal                  <Ldcn.lib>

SYNTAX: byte IoGetADCVal (byte addr, int channel);

PARAMETER1: <addr>    - module address
PARAMETER2: <channel> - 0,1,2 from an I/O node

KEYWORDS: IONodeFunctions

DESCRIPTION: Returns the A/D value from <channel> (0, 1 ,2 from an I/O node).
             Note: this data is only valid if the SEND_ADn (n = 1, 2 or 3)
                   bit has been set in the most recently issued
                   LdcnDefineStat () command.

RETURN VALUE: A/D value from <channel>
END DESCRIPTION **********************************************************/

/*** BeginHeader IoGetADCVal */
     byte IoGetADCVal(byte addr, int channel);
/*** EndHeader */

byte IoGetADCVal(byte addr, int channel) {
  switch (channel) {
    case 0: return mod[addr].kind.io.ad1;
    case 1: return mod[addr].kind.io.ad2;
    case 2: return mod[addr].kind.io.ad3;
  }
  return 0;
}
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
IoSetPWMVal                  <Ldcn.lib>

SYNTAX: bool IoSetPWMVal (byte addr, byte pwm1, byte pwm2);

PARAMETER1: <addr> - module address
PARAMETER2: <pwm1> - PWM1 Data byte
PARAMETER3: <pwm2> - PWM2 Data byte

KEYWORDS: IONodeFunctions

DESCRIPTION: Sets the PWM values for two channels of an I/O node.
             <pwm1> and <pwm2> should be between 0 and 255.

RETURN VALUE: true on success, false on failure
END DESCRIPTION **********************************************************/

/*** BeginHeader IoSetPWMVal */
     bool IoSetPWMVal(byte addr, byte pwm1, byte pwm2);
/*** EndHeader */

bool IoSetPWMVal(byte addr, byte pwm1, byte pwm2) {
  char cmdstr[2];

  mod[addr].kind.io.pwm1 = pwm1;
  mod[addr].kind.io.pwm2 = pwm2;
  cmdstr[0] = pwm1;
  cmdstr[1] = pwm2;

  return LdcnSendCmd(addr, SET_PWM, cmdstr, 2);
}
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
IoSetSynchOutput                  <Ldcn.lib>

SYNTAX: bool IoSetSynchOutput (byte addr, int outbits,
                                   byte pwm1, byte pwm2);

PARAMETER1: <addr>    - module address
PARAMETER2: <outbits> - output bit values
PARAMETER3: <pwm1>    - PWM1 Data byte
PARAMETER4: <pwm2>    - PWM2 Data byte

KEYWORDS: IONodeFunctions

DESCRIPTION: Specify the <output bit> values and the PWM values to be
             output at a later time when LdcnSynchOutput() is called.

RETURN VALUE: true on success, false on failure
END DESCRIPTION **********************************************************/

/*** BeginHeader IoSetSynchOutput */
     bool IoSetSynchOutput(byte addr, int outbits, byte pwm1, byte pwm2);
/*** EndHeader */

bool IoSetSynchOutput(byte addr, int outbits, byte pwm1, byte pwm2) {
  char cmdstr[4];

  mod[addr].kind.io.outbits =  outbits;
  mod[addr].kind.io.pwm1 = pwm1;
  mod[addr].kind.io.pwm2 = pwm2;
  cmdstr[0] = ((char *)(&outbits))[0];
  cmdstr[1] = ((char *)(&outbits))[1];
  cmdstr[2] = pwm1;
  cmdstr[3] = pwm2;
  return LdcnSendCmd(addr, SET_SYNCH_OUT, cmdstr, 4);
}
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
IoGetPWMVal                  <Ldcn.lib>

SYNTAX: byte IoGetPWMVal (byte addr, int channel);

PARAMETER1: <addr>    - module address
PARAMETER2: <channel> - 0, 1, 2 from an I/O node

KEYWORDS: IONodeFunctions

DESCRIPTION: Returns the most recently set PWM value for
             <channel> 0 or 1 of an I/O node.

RETURN VALUE: the last PWM value
END DESCRIPTION **********************************************************/

/*** BeginHeader IoGetPWMVal */
     byte IoGetPWMVal(byte addr, int channel);
/*** EndHeader */

byte IoGetPWMVal(byte addr, int channel) {
  if (channel == 0) return(mod[addr].kind.io.pwm1);
  else return(mod[addr].kind.io.pwm2);
}
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
IoSetTimerMode                  <Ldcn.lib>

SYNTAX: bool IoSetTimerMode (byte addr, byte tmrmode);

PARAMETER1: <addr>    - module address
PARAMETER2: <tmrmode> - timer control byte

KEYWORDS: IONodeFunctions

DESCRIPTION: Sets the counter/timer mode for an I/O node.
             <tmrmode> is the timer control byte and should be
             set to the bitwise OR of the timer control bits.

RETURN VALUE: true on success, false on failure
END DESCRIPTION **********************************************************/

/*** BeginHeader IoSetTimerMode */
     bool IoSetTimerMode(byte addr, byte tmrmode);
/*** EndHeader */

bool IoSetTimerMode(byte addr, byte tmrmode) {
  char cmdstr[2];

  mod[addr].kind.io.timermode = tmrmode;
  cmdstr[0] = tmrmode;

  return LdcnSendCmd(addr, SET_TMR_MODE, cmdstr, 1);
}
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
IoGetTimerMode                  <Ldcn.lib>

SYNTAX: byte IoGetTimerMode (byte addr);

PARAMETER1: <addr> - module address

KEYWORDS: IONodeFunctions

DESCRIPTION: Returns the most recently set timer control byte for an I/O node.

RETURN VALUE: the last timer control byte
END DESCRIPTION **********************************************************/

/*** BeginHeader IoGetTimerMode */
     byte IoGetTimerMode(byte addr);
/*** EndHeader */

byte IoGetTimerMode(byte addr) {  return mod[addr].kind.io.timermode; }
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
IoGetTimerVal                           <Ldcn.lib>

SYNTAX: unsigned long IoGetTimerVal (byte addr);

PARAMETER1: <addr> - module address

KEYWORDS: IONodeFunctions

DESCRIPTION: Returns the timer or counter value from an I/O node.
             Note: this data is only valid if the SEND_TIMER bit has been
             set in the most recently issued LdcnDefineStat () command.

RETURN VALUE: Timer or Counter value from an I/O node.
END DESCRIPTION **********************************************************/

/*** BeginHeader IoGetTimerVal */
     unsigned long IoGetTimerVal(byte addr);
/*** EndHeader */

unsigned long IoGetTimerVal(byte addr) {  return(mod[addr].kind.io.timer); }
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
IoGetTimerSVal                           <Ldcn.lib>

SYNTAX: unsigned long IoGetTimerSVal (byte addr);

PARAMETER1: <addr> - module address

KEYWORDS: IONodeFunctions

DESCRIPTION: Returns the synchronously captured timer or
             counter value from an I/O node.
             Note: this data is only valid if the SEND_SYNC_TMR bit has been
             set in the most recently issued LdcnDefineStat () command.

RETURN VALUE: Synchronously captured timer or counter value from an I/O node
END DESCRIPTION **********************************************************/

/*** BeginHeader IoGetTimerSVal */
     unsigned long IoGetTimerSVal(byte addr);
/*** EndHeader */

unsigned long IoGetTimerSVal(byte addr) {  return(mod[addr].kind.io.timer_s); }
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
IOSynchOutput                  <Ldcn.lib>

SYNTAX: bool IOSynchOutput (byte groupaddr);

PARAMETER1: <groupaddr> - group address

KEYWORDS: IONodeFunctions

DESCRIPTION: Synchronous output command issued to groupaddr. Causes a
             group of modules to synchronously output their previously
             buffered output commands. This will cause an I/O module
             to output previously stored output bit and PWM values.

RETURN VALUE: true on success, false on failure
END DESCRIPTION **********************************************************/

/*** BeginHeader IOSynchOutput */
     bool IOSynchOutput(byte groupaddr);
/*** EndHeader */

// Synchronous output command issued to groupaddr.
bool IOSynchOutput(byte groupaddr) { return LdcnSendCmd(groupaddr, SYNCH_OUT, NULL, 0); }
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
IoGetBitDir                 <Ldcn.lib>

SYNTAX: int IoGetBitDir (byte addr, int bitnum);

PARAMETER1: <addr>   - module address
PARAMETER2: <bitnum> - bit number

KEYWORDS: IONodeFunctions

RETURN VALUE: returns 0 if a IO module I/O bit  is defined as an output,
                      1 if defined as an input.
END DESCRIPTION **********************************************************/

/*** BeginHeader IoGetBitDir */
     int IoGetBitDir(byte addr, int bitnum);
/*** EndHeader */

int IoGetBitDir(byte addr, int bitnum) { return ((mod[addr].kind.io.bitdir >> bitnum) & 1); }
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
IoBitDirOut                 <Ldcn.lib>

SYNTAX: bool IoBitDirOut (byte addr, int bitnum);

PARAMETER1: <addr>   - module address
PARAMETER2: <bitnum> - number of the bit to be set as output

KEYWORDS: IONodeFunctions

DESCRIPTION: Sets the direction of an I/O bit to be an output bit.

RETURN VALUE: true on success, false on failure

END DESCRIPTION **********************************************************/

/*** BeginHeader IoBitDirOut */
     int IoBitDirOut(byte addr, int bitnum);
/*** EndHeader */

int IoBitDirOut(byte addr, int bitnum) {
  mod[addr].kind.io.bitdir = mod[addr].kind.io.bitdir & (int)(~(1 << bitnum));
  return LdcnSendCmd(addr, SET_IO_DIR, (char *)(&(mod[addr].kind.io.bitdir)), 2);
}
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
IoBitDirIn                 <Ldcn.lib>

SYNTAX: int IoBitDirIn (byte addr, int bitnum);

PARAMETER1: <addr>   - module address
PARAMETER2: <bitnum> - number of the bit to be set as input

KEYWORDS: IONodeFunctions

DESCRIPTION: Sets the direction of an I/O bit to be an input bit.

RETURN VALUE: true on success, false on failure
END DESCRIPTION **********************************************************/

/*** BeginHeader IoBitDirIn */
     int IoBitDirIn(byte addr, int bitnum);
/*** EndHeader */

int IoBitDirIn(byte addr, int bitnum) {

  mod[addr].kind.io.bitdir = mod[addr].kind.io.bitdir | (int)(1 << bitnum);
  return LdcnSendCmd(addr, SET_IO_DIR, (char *)(&(mod[addr].kind.io.bitdir)), 2);
}

// ------------------------------------------------------------------------
// L D C N C O M  F U N C T O N S -----------------------------------------
// ------------------------------------------------------------------------

// Initialize misc network variables

/*** BeginHeader InitLdcnVars */
     int InitLdcnVars(void);
/*** EndHeader */

int InitLdcnVars(void) {
  int i;

    segchain _GLOBAL_INIT {
      ComPort = INVALID_HANDLE_VALUE;
      nummod = max_nummod = SioError = IOBusy = 0;
      BaudRate = 0;
      net_num = 1; LdcnSetNet(1);
    }

    for (i = 0; i <= max_nummod; i++) {
      mod[i].modtype = 0xFF;
      mod[i].modver = 0;
      mod[i].stat = 0;
      mod[i].statusitems = 0;
      mod[i].groupaddr   = 0xFF;
      mod[i].groupleader = false;
    }
}

//------------------------ LDCNetwork Functions -----------------------------

/* START FUNCTION DESCRIPTION ********************************************
LdcNetworkFunctions             <Ldcn.lib>

long BaudRate;

bool LdcnSetNet(int netN);
handle GetComPort();
int  GetSioError();
int  IsBusy();
void FixSioError();
bool LdcnHardReset();
bool LdcnChangeBaud(byte groupaddr, long baudrate);
int  LdcnInit(int portname, long baudrate);
int  LdcnFullInit(int portname, long baudrate);
bool LdcnSendCmd(byte addr, byte cmd, char *datastr, byte n );
bool LdcnSetGroupAddr(byte addr, byte groupaddr, bool leader);
bool LdcnSynchInput(byte groupaddr);
bool LdcnNoOp(byte addr);
bool LdcnReadStatus(byte addr, byte statusitems);
bool LdcnDefineStatus(byte addr, byte statusitems);
byte LdcnGetStat(byte addr);
byte LdcnGetStatItems(byte addr);
byte LdcnGetModType(byte addr);
byte LdcnGetModVer(byte addr);
byte LdcnGetGroupAddr(byte addr);
bool LdcnGroupLeader(byte addr);
void LdcnShutdown();
END DESCRIPTION **********************************************************/

/*** BeginHeader BaudRate */
     extern long BaudRate;
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
GetComPort                    <Ldcn.lib>

SYNTAX: handle GetComPort ();

KEYWORDS: LdcNetworkFunctions

RETURN VALUE: The handle of ComPort, opened by LdcnInit()
END DESCRIPTION **********************************************************/

/*** BeginHeader GetComPort */
     handle GetComPort();
/*** EndHeader */

handle GetComPort() {  return ComPort; }
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
GetSioError                 <Ldcn.lib>

SYNTAX: int GetSioError ();

KEYWORDS: LdcNetworkFunctions

RETURN VALUE: The number of serial IO errors
END DESCRIPTION **********************************************************/

/*** BeginHeader GetSioError */
     int GetSioError();
/*** EndHeader */

int GetSioError() {  return SioError; }
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
IsBusy                 <Ldcn.lib>

SYNTAX: int IsBusy ();

KEYWORDS: LdcNetworkFunctions

RETURN VALUE: returns IO status - busy /true/ or ready /false/
END DESCRIPTION **********************************************************/

/*** BeginHeader IsBusy */
     int IsBusy();
/*** EndHeader */

int IsBusy() {  return IOBusy; }

//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
FixSioError                  <Ldcn.lib>

SYNTAX: void FixSioError ();

KEYWORDS: LdcNetworkFunctions

DESCRIPTION: Attempts to re-synch communications sending out to the
             COM port a null string and clears the input buffer.

RETURN VALUE: none
END DESCRIPTION **********************************************************/

/*** BeginHeader FixSioError */
     void FixSioError();
/*** EndHeader */

void FixSioError() {
  char teststr[2];
  int i;

// If too many errors - prompt to reset

  if (SioError >= MAXSIOERROR)  return;

// Otherwise, send out a null string to re-synch
  teststr[0] = 0;
  for (i = 0; i < 30; i++) SioPutChars(ComPort, teststr, 1);
  delay(100);
  SioClrInbuf(ComPort);
}
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
LdcnSendCmd                  <Ldcn.lib>

SYNTAX: bool LdcnSendCmd (byte addr, byte cmd, char *datastr, byte n);

PARAMETER1: <addr>    - receiver module address
PARAMETER2: <cmd>     - command byte
PARAMETER3: <datastr> - sended data structure
PARAMETER4: <n>       - bytes number to send

KEYWORDS: LdcNetworkFunctions

DESCRIPTION: Sends to module(s) at address <addr> the command byte <cmd> followed
             by <n> additional data bytes in <datastr> and calculates the number
             of bytes to be received. Shoves the returned status data in the
             internal structure mod []. This function does not make syntax
             analysis of the command and does not store sent values in the
             internal structure mod[]. That's why it is not recommended to use
             this function directly. Better practice is to invoke higher-level
             functions from Servo, Stepper and I/O groups.

RETURN VALUE: true - on success, false on failure
END DESCRIPTION **********************************************************/

/*** BeginHeader LdcnSendCmd */
     bool LdcnSendCmd(byte addr, byte cmd, char *datastr, byte n );
/*** EndHeader */

bool LdcnSendCmd(byte addr, byte cmd, char *datastr, byte n ) {
  byte cksum;
  byte i;
  bool iostat;
  byte stataddr;            // address of the "answering" device
  char cstr[30];

  stataddr = 0;
  if (addr < 0x80)          // addr is a individual address
    stataddr = addr;
  else                      // addr is a group address
    for (i=1; i <= nummod; i++)
      if ((mod[i].groupaddr == addr) && (mod[i].groupleader)) // there is a group leader
         { stataddr = i; break; }                             // that will answer

// If too many SIO errors, punt
  if (SioError > MAXSIOERROR)
    return(false);

// Check if data is to be returned from to a known module type
  if ( !( ( mod[stataddr].modtype==STEPMODTYPE) ||
          ( mod[stataddr].modtype==SERVOHYBTYPE) ||
          ( mod[stataddr].modtype==SERVOMODTYPE) ||
          ( mod[stataddr].modtype==IOMODTYPE) ) ) {
      return (false);
  }

// Calculate the adjust command byte, calculate checksum and send the command
  cksum = 0;
  cstr[0] = (char)0xAA;	// start with header byte
  cstr[1] = addr;	// add on address byte
  cksum += cstr[1];
  cstr[2] = (byte)(((n<<4) & 0xF0) | cmd);
  cksum += cstr[2];
  for (i = 0; i < n; i++) {
    cstr[i+3] = datastr[i];
    cksum += cstr[i+3];
  }
  cstr[n+3] = cksum;

  IOBusy = true;

  SioClrInbuf(ComPort);              // Get rid of any old input chars
  SioPutChars(ComPort, cstr, n+4);   // Send the command string

  if (stataddr == 0) {   // If a group command w/ no leader, add delay then exit
    delay(60);
    IOBusy = false;
    return true;
  }

//  delay( 20);
  switch (mod[stataddr].modtype) {
    case STEPMODTYPE:  iostat = StepGetStat(stataddr);  break;
    case SERVOHYBTYPE:
    case SERVOMODTYPE: iostat = ServoGetStat(stataddr); break;
    case IOMODTYPE:    iostat = IoGetStat(stataddr);    break;
  }

  if (iostat == false) { SioError++;  FixSioError(); }
  else                   SioError = 0;

  IOBusy = false;
  return iostat;
}
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
LdcnChangeBaud                  <Ldcn.lib>

SYNTAX: bool LdcnChangeBaud (byte groupaddr, long baudrate);

PARAMETER1: <groupaddr> -  group address
PARAMETER2: <baudrate> -   new baund rate

KEYWORDS: LdcNetworkFunctions

DESCRIPTION:Changes the baud rate of all controllers with group address <groupaddr>
            and also changes host's baud rate. <groupaddr> should include all
            modules. A status packet returned from this command would be at the
            new baud rate, so typically (unless the host's baud rate can be accurately
            synchronized) there should be no group leader when this command is issued.

RETURN VALUE: true - on success, false on failure.
END DESCRIPTION **********************************************************/

/*** BeginHeader LdcnChangeBaud */
     bool LdcnChangeBaud(byte groupaddr, long baudrate);
/*** EndHeader */

bool LdcnChangeBaud(byte groupaddr, long baudrate) {
  char cstr[5];

  cstr[0] = (char) 0xAA;	                  // Header
  cstr[1] = groupaddr;
  cstr[2] = 0x10 | SET_BAUD;

  if (baudrate ==  9600)          cstr[3] = PB9600;
  else if (baudrate == 19200)     cstr[3] = PB19200;
  else if (baudrate == 57600)     cstr[3] = PB57600;
  else if (baudrate == 115200)    cstr[3] = PB115200;
  else {   cstr[3] = PB19200;     baudrate = 19200; }

  cstr[4] = (byte)(cstr[1] + cstr[2] + cstr[3]);  // checksum
  SioPutChars(ComPort, cstr, 5);                  // send command
  delay(100);	     	             //Wait for command to execute

  SioChangeBaud(ComPort, baudrate);  //Reset the baud rate to the default

  SioClrInbuf(ComPort);              //clear out any random crap left in buffer
  delay(100);

  BaudRate = baudrate;
  return true;
}
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
LdcnSynchInput                  <Ldcn.lib>

SYNTAX: bool LdcnSynchInput (byte groupaddr);

PARAMETER1: <groupaddr> - Group address

KEYWORDS: LdcNetworkFunctions

DESCRIPTION:Synchronous input command issued to groupaddr. Causes a group of modules
            to synchronously capture input values. This will cause a SERVO module to
            store its current position as the home position and it will cause an I/O
            node to store its input bits and timer values.

RETURN VALUE: true - on success, false on failure
END DESCRIPTION **********************************************************/

// Synchronous input command issued to groupaddr.

/*** BeginHeader LdcnSynchInput */
     bool LdcnSynchInput(byte groupaddr);
/*** EndHeader */

bool LdcnSynchInput(byte groupaddr) { return LdcnSendCmd(groupaddr, SYNCH_INPUT, NULL, 0); }
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
LdcnNoOp                  <Ldcn.lib>

SYNTAX: bool LdcnNoOp (byte addr);

PARAMETER1: <addr> - module address

KEYWORDS: LdcNetworkFunctions

DESCRIPTION: Issued a No Operation command to module(s) at address
             <addr>, simply causing its currently defined items of
             status data to be returned.

RETURN VALUE: true - on success, false on failure

END DESCRIPTION **********************************************************/

/*** BeginHeader LdcnNoOp */
     bool LdcnNoOp(byte addr);
/*** EndHeader */

bool LdcnNoOp(byte addr) { return LdcnSendCmd(addr, NOP, NULL, 0); }
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
LdcnSetGroupAddr                  <Ldcn.lib>

SYNTAX: bool LdcnSetGroupAddr (byte addr, byte groupaddr, bool leader) ;

PARAMETER1: <addr>      - receiver module address
PARAMETER2: <groupaddr> - New group address /between 0x80 and 0xFF/
PARAMETER3: <leader>    - mark receiver module as leader or not

KEYWORDS: LdcNetworkFunctions

DESCRIPTION: Sends the  Set Address  command to  module(s) at  address <addr>. Sets the
             group  address  of  a  controller.  If  leader  is  true,  the specified
             controller becomes the group leader. Only one leader should be  specified
             for any group address.

RETURN VALUE: true - on success, false on failure
END DESCRIPTION **********************************************************/

/*** BeginHeader LdcnSetGroupAddr */
     bool LdcnSetGroupAddr(byte addr, byte groupaddr, bool leader);
/*** EndHeader */

bool LdcnSetGroupAddr(byte addr, byte groupaddr, bool leader) {
  char cstr[2];

  if (!(groupaddr & 0x80)) return false;  // punt if not valid group address

  cstr[0] = addr;
  cstr[1] = groupaddr;
  if (leader) cstr[1] &= 0x7F;            // clear upper bit if a group leader
  mod[addr].groupaddr = groupaddr;
  mod[addr].groupleader = leader;
  return LdcnSendCmd(addr, SET_ADDR, cstr, 2);
}
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
LdcnHardReset                  <Ldcn.lib>

SYNTAX: bool LdcnHardReset ();

KEYWORDS: LdcNetworkFunctions

DESCRIPTION: Reset all controllers - uses universal reset address 0xFF
             and set default values.

RETURN VALUE: true on success, false on failure
END DESCRIPTION **********************************************************/

// Reset all controllers - uses universal reset address 0xFF

/*** BeginHeader LdcnHardReset */
     bool LdcnHardReset();
/*** EndHeader */

bool LdcnHardReset() {
  char cstr[5];
  int i;

  nummod   = 0;
  SioError = 0;	               // reset the number of errors to 0
  IOBusy = false;

// Send string of 0's to flush input buffers
  cstr[0] = 0;
  for (i = 0; i < 20; i++) SioPutChars(ComPort, cstr, 1);

// Send out reset command string
  cstr[0] = (char) 0xAA;               // Header
  cstr[1] = (char) 0xFF;
  cstr[2] = HARD_RESET;
  cstr[3] = (byte)(cstr[1] + cstr[2]); // checksum
  SioPutChars(ComPort, cstr, 4);       // send reset

  delay( 100);                         // wait for reset to execute

  SioChangeBaud(ComPort, 19200);       // Reset the baud rate to the default
  SioClrInbuf(ComPort);                // clear out any random crap left in buffer
  return true;
}
//-------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
LdcnReadStatus                  <Ldcn.lib>

SYNTAX: bool LdcnReadStatus (byte addr, byte statusitems);

PARAMETER1: <addr>        - module address
PARAMETER2: <statusitems> - status items to be read

KEYWORDS: LdcNetworkFunctions

DESCRIPTION: Reads status data from a module without changing the
             default status data. <Statusitems> should be set to
             the bitwise OR of the status items.

RETURN VALUE: true - on success, false on failure
END DESCRIPTION **********************************************************/

/*** BeginHeader LdcnReadStatus */
     bool LdcnReadStatus(byte addr, byte statusitems);
/*** EndHeader */

bool LdcnReadStatus(byte addr, byte statusitems) {
  byte oldstat;
  bool retval;
  char cstr[1];

// set bit 7 to 0 for stepper
  statusitems = (mod[addr].modtype == STEPMODTYPE ? statusitems & 0x7F : statusitems);
  cstr[0] = statusitems;
  oldstat = mod[addr].statusitems;
  mod[addr].statusitems = statusitems;
  retval = LdcnSendCmd(addr, READ_STAT, cstr, 1);
  mod[addr].statusitems = oldstat;

  return retval;
}
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
LdcnDefineStatus                   <Ldcn.lib>

SYNTAX: bool LdcnDefineStatus (byte addr, byte statusitems);

PARAMETER1: <addr>        - module address
PARAMETER2: <statusitems> - status items to be included in the status packet

KEYWORDS: LdcNetworkFunctions

DESCRIPTION: For module(s) at address <addr>, defines which status
             data will always be sent back with each command by
             sending DefineStatus command. <Statusitems> should be set
             to the bitwise OR of the status items.

RETURN VALUE: true - on success, false on failure
END DESCRIPTION **********************************************************/

/*** BeginHeader LdcnDefineStatus */
     bool LdcnDefineStatus(byte addr, byte statusitems);
/*** EndHeader */

bool LdcnDefineStatus(byte addr, byte statusitems) {
  char cstr[1];

  cstr[0] = statusitems;
  mod[addr].statusitems = statusitems;
  return LdcnSendCmd(addr, DEF_STAT, cstr, 1);
}
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
LdcnGetStat                  <Ldcn.lib>

SYNTAX: byte LdcnGetStat (byte addr);

PARAMETER1: <addr> - module address

KEYWORDS: LdcNetworkFunctions

DESCRIPTION: Returns the last status byte of module at address <addr>.

RETURN VALUE: The last status byte
END DESCRIPTION **********************************************************/

/*** BeginHeader LdcnGetStat */
     byte LdcnGetStat(byte addr);
/*** EndHeader */

byte LdcnGetStat(byte addr) {  return mod[addr].stat; }
//---------------------------------------------------------------------------


/* START FUNCTION DESCRIPTION ********************************************
LdcnGetStatItems                  <Ldcn.lib>

SYNTAX: byte LdcnGetStatItems (byte addr);

PARAMETER1: <addr> - module address

KEYWORDS: LdcNetworkFunctions

DESCRIPTION: Returns the byte specifying the default status items
             to be returned in the status data packet - the last
             sent parameter of the DefineStatus command.

RETURN VALUE: Last status item  byte
END DESCRIPTION **********************************************************/

/*** BeginHeader LdcnGetStatItems */
     byte LdcnGetStatItems(byte addr);
/*** EndHeader */

byte LdcnGetStatItems(byte addr) {  return mod[addr].statusitems; }
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
LdcnGetModType                  <Ldcn.lib>

SYNTAX: byte LdcnGetModType (byte addr);

PARAMETER1: <addr> - address

KEYWORDS: LdcNetworkFunctions

DESCRIPTION: Returns the module type of a particular module.
             This value will either be SERVOMODTYPE (0), IOMODTYPE (2),
             STEPMODTYPE (3) or SERVOHYBTYPE (90)

RETURN VALUE: module type byte.
END DESCRIPTION **********************************************************/

/*** BeginHeader LdcnGetModType */
     byte LdcnGetModType(byte addr);
/*** EndHeader */

byte LdcnGetModType(byte addr) { return mod[addr].modtype; }
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
LdcnGetModVer                  <Ldcn.lib>

SYNTAX: byte LdcnGetModVer (byte addr);

PARAMETER1: <addr> - module address

KEYWORDS: LdcNetworkFunctions

DESCRIPTION: Returns the firmware version number of a particular module.

RETURN VALUE: firmware version number
END DESCRIPTION **********************************************************/

/*** BeginHeader LdcnGetModVer */
     byte LdcnGetModVer(byte addr);
/*** EndHeader */

byte LdcnGetModVer(byte addr) { return mod[addr].modver; }
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
LdcnGetGroupAddr                  <Ldcn.lib>

SYNTAX: byte LdcnGetGroupAddr (byte addr);

PARAMETER1: <addr> - module address

KEYWORDS: LdcNetworkFunctions

RETURN VALUE: Returns the group address of a particular module.

END DESCRIPTION **********************************************************/

/*** BeginHeader LdcnGetGroupAddr */
     byte LdcnGetGroupAddr(byte addr);
/*** EndHeader */

byte LdcnGetGroupAddr(byte addr) { return mod[addr].groupaddr; }
//---------------------------------------------------------------------------


/* START FUNCTION DESCRIPTION ********************************************
LdcnGroupLeader                  <Ldcn.lib>

SYNTAX: bool LdcnGroupLeader (byte addr);

PARAMETER1: <addr> - module address

KEYWORDS: LdcNetworkFunctions

RETURN VALUE: Returns true if the specified module is a group leader, false if not.
END DESCRIPTION **********************************************************/

/*** BeginHeader LdcnGroupLeader */
     bool LdcnGroupLeader(byte addr);
/*** EndHeader */

bool LdcnGroupLeader(byte addr) { return mod[addr].groupleader; }
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
LdcnShutdown                  <Ldcn.lib>

SYNTAX: void LdcnShutdown ();

KEYWORDS: LdcNetworkFunctions

DESCRIPTION: Cleans up the internal data structure mod [], resets
             all LDCN modules to their power-up state by sending
             HardReset command and closes previously opened COM port.

RETURN VALUE: none
END DESCRIPTION **********************************************************/

/*** BeginHeader LdcnShutdown */
     void LdcnShutdown(void);
/*** EndHeader */

void LdcnShutdown(void) {
  if ((ComPort!=INVALID_HANDLE_VALUE) && (ComPort!=NULL)) LdcnHardReset();
  SioClose(ComPort);
  ComPort = INVALID_HANDLE_VALUE;
}
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
LdcnInit                 <Ldcn.lib>

SYNTAX: int LdcnInit (int portname, long baudrate);

PARAMETER1: <portname> -  COM port number - to open
PARAMETER2: <baudrate> -  baud rate for group address 0xFF (all devices).

KEYWORDS: LdcNetworkFunctions

DESCRIPTION: Initializes all modules on the LDCN network with unique
             sequential addresses starting at 1 and establishes their
             device types. All modules are assigned a group address
             of 0xFF. Device type and version information is stored
             in the internal data structure mod [].

RETURN VALUE: Returns the number of modules found on the network.
END DESCRIPTION **********************************************************/

/*** BeginHeader LdcnInit */
     int LdcnInit(int portname, long baudrate);
/*** EndHeader */

int LdcnInit(int portname, long baudrate) {
  char cstr[6];
  int numread;
  byte addr, i;

  BaudRate = baudrate;
  InitLdcnVars();

  ComPort = SioOpen(portname, 19200);    // Open with default rate of 19200
  if ( ComPort == INVALID_HANDLE_VALUE )  return 0;

  for (i = 0; i <= ABS_MAXNUMMOD; i++) {
    cstr[0] = (char) 0xAA;	         // Header
    cstr[1] = i;
    cstr[2] = CLEAR_BITS;
    cstr[3] = (byte)(cstr[1] + cstr[2]); // checksum
    SioPutChars(ComPort, cstr, 4);       // Send command Clear Sticky Bits
  }

  LdcnHardReset();
  LdcnHardReset();

  addr = 1;
  while (1) {
// First set the address to a unique value:
    cstr[0] = (char) 0xAA;       // Header
    cstr[1] = 0;                 // Send to default address of 0
    cstr[2] = 0x20 | SET_ADDR;
    cstr[3] = addr;              // Set new address sequentially
    cstr[4] = (char) 0xFF;       // Set group address to 0xFF
    cstr[5] = (byte)(cstr[1] + cstr[2] + cstr[3] + cstr[4]);    // checksum
    SioPutChars(ComPort, cstr, 6);                              // Send command

//    delay( 20);

    numread = SioGetChars(ComPort, cstr, 2); // get back status, cksum
    if (numread != 2) break;                 // if no response, punt out of loop
    if (cstr[0] != cstr[1]) {
        SioClose(ComPort);
        return(0);
    }

// Read the device type
    cstr[0] = (char) 0xAA;         // Header
    cstr[1] = addr;                // Send to addr
    cstr[2] = 0x10 | READ_STAT;
    cstr[3] = SEND_ID;             // send ID only
    cstr[4] = (byte)(cstr[1] + cstr[2] + cstr[3]);  // checksum
    SioPutChars(ComPort, cstr, 5);                  // Send command

//    delay( 20);

    numread = SioGetChars(ComPort, cstr, 4);  // get back stat, type, ver, cksum
    if (numread != 4) {
        SioClose(ComPort);
        return(0);
    }

    if (addr > max_nummod) { printf("ERROR in define of MAXNUMMODx\n"); return 0;}

    mod[addr].stat    = cstr[0];
    mod[addr].modtype = cstr[1];
    mod[addr].modver  = cstr[2];
    mod[addr].statusitems = 0;
    mod[addr].groupaddr   = 0xFF;
    mod[addr].groupleader = false;
    switch (mod[addr].modtype)	{
        case STEPMODTYPE:  StepNewMod(addr); break;
        case SERVOHYBTYPE:
        case SERVOMODTYPE: ServoNewMod(addr); break;
        case IOMODTYPE:    IoNewMod(addr);    break;
    }
    addr++;  // increment the address
  }

  nummod = addr-1;
  if (nummod > 0)
    LdcnChangeBaud(0xFF, baudrate);
  else
    SioClose(ComPort);

  return(nummod);  // Return number of modules
}
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
LdcnFullInit                 <Ldcn.lib>

SYNTAX: int LdcnFullInit (int portname, long baudrate);

PARAMETER1: <portname> -  COM port number - to open
PARAMETER2: <baudrate> -  baud rate for group address 0xFF (all devices).

KEYWORDS: LdcNetworkFunctions

DESCRIPTION: Initializes all modules on the LDCN network with unique
             sequential addresses starting at 1 and establishes their
             device types. All modules are assigned a group address
             of 0xFF. Device type and version information is stored
             in the internal data structure mod [].

RETURN VALUE: Returns the number of modules found on the network.
END DESCRIPTION **********************************************************/

/*** BeginHeader LdcnFullInit */
     int LdcnFullInit(int portname, long baudrate);
/*** EndHeader */

int LdcnFullInit(int portname, long baudrate) {
  char cstr[6];
  char chbr[6];
  char zstr[20];
  int numread;
  byte addr, i;
  long BaudRates[4];
  int found, br;

  BaudRate = baudrate;

  BaudRates[0] =  19200;
  BaudRates[1] =   9600;
  BaudRates[2] =  57600;
  BaudRates[3] = 115200;

  InitLdcnVars();

  ComPort = SioOpen(portname, BaudRates[0]);  // Open with default rate of 19200
  if ( ComPort == INVALID_HANDLE_VALUE )  return 0;

  for (br = 0; br < 4; br++) {                // Send HardReset at all baudrates
    if (!SioChangeBaud(ComPort, BaudRates[br])) { SioClose(ComPort); return 0;}
    LdcnHardReset();
    for (i = 0; i < ABS_MAXNUMMOD; i++) {
        cstr[0] = (char) 0xAA;	              // Header
        cstr[1] = i;
        cstr[2] = CLEAR_BITS;
        cstr[3] = (byte)(cstr[1] + cstr[2]);  // checksum
       SioPutChars(ComPort, cstr, 4);         // Send command Clear Sticky Bits
    }
    LdcnHardReset();
  }

  for (i = 0; i < 20; i++) zstr[i] = 0;       // Prepare string of 20 zeros
  chbr[0] = (char) 0xAA;                      // Prepare Change Baud Rate command string
  chbr[2] = 0x10 | SET_BAUD;

  if (BaudRate ==  9600)       chbr[3] = PB9600;
  else if (BaudRate == 19200)  chbr[3] = PB19200;
  else if (BaudRate == 57600)  chbr[3] = PB57600;
  else if (BaudRate == 115200) chbr[3] = PB115200;
  else {   BaudRate = 19200;   chbr[3] = PB19200;   }

  found = addr = 1;
// If there are devices with default baud rate 9600: br < 2
  while (found) for (br = 0; br < 1; br++) {
    if (!SioChangeBaud(ComPort, BaudRates[br])) { SioClose(ComPort); return 0; }
// Clear Com port
    SioPutChars(ComPort, zstr, 20);
    SioClrInbuf(ComPort);
// Send Clear Sticky Bits to addr 0
    cstr[0] = (char) 0xAA;	              // Header
    cstr[1] = 0;
    cstr[2] = CLEAR_BITS;
    cstr[3] = (byte)(cstr[1] + cstr[2]);      // checksum
    SioPutChars(ComPort, cstr, 4);            // Send command Clear Sticky Bits
    numread = SioGetChars(ComPort, cstr, 2);

// First set the address to a unique value:
    cstr[0] = (char) 0xAA; 	              // Header
    cstr[1] = 0;  	                      // Send to default address of 0
    cstr[2] = 0x20 | SET_ADDR;
    cstr[3] = addr;  	                      // Set new address sequentially
    cstr[4] = (char) 0xFF;                    // Set group address to 0xFF
    cstr[5] = (byte)(cstr[1] + cstr[2] + cstr[3] + cstr[4]);  // checksum
    SioPutChars(ComPort, cstr, 6);            // Send command
    numread = SioGetChars(ComPort, cstr, 2);  // get back status, cksum
        // For Default 9600 br == 1
    if (numread != 2) { if (br == 0) found = 0;  continue; } // if no response try next baudrate
    if (cstr[0] != cstr[1]) { SioClose(ComPort); return(0); }

// Read the device type
    cstr[0] = (char) 0xAA;  	              // Header
    cstr[1] = addr;  		              // Send to addr
    cstr[2] = 0x10 | READ_STAT;
    cstr[3] = SEND_ID;                        // send ID only
    cstr[4] = (byte)(cstr[1] + cstr[2] + cstr[3]);
    SioPutChars(ComPort, cstr, 5);            // Send command
    numread = SioGetChars(ComPort, cstr, 4);  // get back stat, type, ver, cksum

    if (numread != 4) { SioClose(ComPort); return(0); }
    mod[addr].stat    = cstr[0];
    mod[addr].modtype = cstr[1];
    mod[addr].modver  = cstr[2];
    mod[addr].statusitems = 0;
    mod[addr].groupaddr   = 0xFF;
    mod[addr].groupleader = false;
    switch (mod[addr].modtype)	{
      case SERVOMODTYPE:
      case SERVOHYBTYPE: ServoNewMod(addr); break;
      case IOMODTYPE:    IoNewMod(addr);    break;
      case STEPMODTYPE:  StepNewMod(addr);  break;
    }

    chbr[1] = addr;
    chbr[4] = (byte)(chbr[1] + chbr[2] + chbr[3]);
    SioPutChars(ComPort, chbr, 5);            // send command Change Baud Rate
    delay(100);	     	                      // Wait for command to execute
    SioClrInbuf(ComPort);

    addr++;		                      // increment the address
    br = 100;                                 // if found at 9600
  }

  nummod = addr-1;
  if (!nummod) { SioClose(ComPort); return 0; }

  SioChangeBaud(ComPort, BaudRate);
// Clear Com port
  SioPutChars(ComPort, zstr, 20);
  SioClrInbuf(ComPort);

  for (addr = 1; addr <= nummod; addr++)  {
      cstr[0] = (char) 0xAA;	              // Header
      cstr[1] = addr;
      cstr[2] = CLEAR_BITS;
      cstr[3] = (byte)(cstr[1] + cstr[2]);    // checksum
      SioPutChars(ComPort, cstr, 4);          // Send command Clear Sticky Bits
      i = SioGetChars(ComPort, cstr, 2);      // get back status, cksum
      delay(100);
      SioPutChars(ComPort, cstr, 4);          // Send command Clear Sticky Bits
      i = SioGetChars(ComPort, cstr, 2);      // get back status, cksum
  }

  return(nummod);                             // Return number of modules
}


//---------------------------------------------------------------------------
// COORDINATED MOTION CONTROL -----------------------------------------------
//---------------------------------------------------------------------------


/* START FUNCTION DESCRIPTION ********************************************
CoordinatedMotion                 <Ldcn.lib>

#define MAXSEG 100     -- Maximum number of segments
#define TWOPI 6.28319

void SetTangentTolerance(float theta);
void SetFeedrate(float fr);
int  SetPathParams(int freq, int nbuf, int xaxis, int yaxis, int zaxis, int groupaddr,
                   float xscale, float yscale, float zscale, float accel, float decel);
void ClearSegList(float xi, float yi, float zi);
int  AddLineSeg(float x, float y, float z);
int  AddArcSeg( float x, float y, float z,     // end point
                float cx, float cy, float cz,  // center point
                float nx, float ny, float nz); // normal
float InitPath();
int   AddPathPoints();
int   SegmentsInBuffer();
END DESCRIPTION **********************************************************/

/*** BeginHeader  */
#define MAXSEG 100     // Maximum number of segments
#ifndef PI
  #define PI (double) 3.14159265358979323846
#endif
#define TWOPI 6.28319
/*** EndHeader */

//---------------------------------------------------------------------------

#define DTOR 0.017453

// Segment types:
#define LINE 0
#define ARC 1

// Valuse for tangent tolerance
#define TAN_1DEGREE 0.99985
#define TAN_3DEGREE 0.99863
#define TAN_5DEGREE 0.99619
#define TAN_10DEGREE 0.98481
#define TAN_20DEGREE 0.93969
#define TAN_45DEGREE 0.70711

// Data types:

typedef float fp[3];     // floating point 3x1 vector
typedef long int ip[3];  // integer 3x1 vector

typedef struct {         // data type for line segments or arc segments
  int type;              // LINE or ARC
  fp p1;                 // Starting point
  fp p2;                 // Ending point
  fp c;                  // Center point (arcs only)
  fp norm;               // Normal vector (arcs only)
  float len;             // Segment length
  float r;               // Radius (arcs only)
} segment;

typedef struct {         // data type for a coordinate frame
  fp x;
  fp y;
  fp z;
  fp p;
} frame;

//---------------------------------------------------------------------
// Globals:

int pathsize;                 // local path size
segment seglist[MAXSEG];      // list of segments
bool seg_is_added;
int curppoint;                // current pathpoint
float tan_tolerance;          // minimum cos(th) for angle between tangents
frame cur_arcframe;           // coordinate fram for the current arc
float pathlen;                // total path length
float arclen;                 // total length of path already downloaded
float stublen;                // length of path in current segment
int pathfreq;                 // selected path frequency
int bufsize;                  // max num points to store in the PIC-SERVO buffer
float maxvel, vel, acc, decl; // max. velocity, cur velocity, accel & decel
byte x;                       // axes addresses
byte y;
byte z;
byte group;                   // group address for coordinated controllers
int at_end;                   // flags when we are at end of path
float xoff, yoff, zoff;       // origin offset
float UTOCX, UTOCY, UTOCZ;    // Units TO Counts conversion factors
float tolerance;              // small distance tolerance use for near-zero comparisons

int slhead, sltail;           // pointers to head and tail of the segment list
bool IsPathInitialized;
int path_net_num;
//---------------------------------------------------------------------

//---------------------------------------------------------------------------
// Coordinated motion control functions
//---------------------------------------------------------------------------


// Pointer functions
// increment segment list head pointer
void inc_slhead()  {  slhead++;  if (slhead == MAXSEG) slhead = 0; }

//---------------------------------------------------------------------------
// decrement segment list head pointer
void dec_slhead()  {  slhead--;  if (slhead == -1) slhead = MAXSEG - 1; }

//---------------------------------------------------------------------------
// increment segment list tail pointer
void inc_sltail()  {  sltail++;  if (sltail == MAXSEG) sltail = 0; }

//---------------------------------------------------------------------------
//return the segment ptr before slhead
int prev_seg()  {
int ptr;

  ptr = slhead - 1;
  if (ptr == -1) ptr = MAXSEG - 1;
  return(ptr);
}


//---------------------------------------------------------------------------
//  Geometric functions

// Returns the magnitude of a floating point vector
float mag(fp p) { return(sqrt(p[0]*p[0] + p[1]*p[1] + p[2]*p[2])); }

//---------------------------------------------------------------------------

// Returns the dot product of two floating point vectors
float dot(fp x, fp y) { return( x[0]*y[0] + x[1]*y[1] + x[2]*y[2] ); }

//---------------------------------------------------------------------------
// Z is returned as the cross product of (x cross y)
void cross(fp x, fp y, fp z) {
  z[0] = x[1]*y[2] - x[2]*y[1];
  z[1] = x[2]*y[0] - x[0]*y[2];
  z[2] = x[0]*y[1] - x[1]*y[0];
}
//---------------------------------------------------------------------------
// y = normalized x   ( normalize(x,x) works OK )
float normalize(fp x, fp y) {
float a;

  a = mag(x);
  if (a==0.0) return(a);

  y[0] /= a;  y[1] /= a;  y[2] /= a;

  return(a);
}
//---------------------------------------------------------------------------
// Coordinate frame transformation: y =  F*x, ( y = F*y OK )
void fvmult(frame *F, fp x, fp y) {
fp xtemp;

  xtemp[0] = x[0];
  xtemp[1] = x[1];
  xtemp[2] = x[2];
  y[0] = F->x[0]*xtemp[0] + F->y[0]*xtemp[1] + F->z[0]*xtemp[2] + F->p[0];
  y[1] = F->x[1]*xtemp[0] + F->y[1]*xtemp[1] + F->z[1]*xtemp[2] + F->p[1];
  y[2] = F->x[2]*xtemp[0] + F->y[2]*xtemp[1] + F->z[2]*xtemp[2] + F->p[2];
}
//---------------------------------------------------------------------------
// Coordinate frame inversion: *B = inverse(A)
void finvert(frame A, frame *B) {
  B->x[1] = A.y[0];
  B->x[2] = A.z[0];
  B->y[2] = A.z[1];
  B->y[0] = A.x[1];
  B->z[0] = A.x[2];
  B->z[1] = A.y[2];
  B->x[0] = A.x[0];
  B->y[1] = A.y[1];
  B->z[2] = A.z[2];
  B->p[0] = -A.x[0]*A.p[0] - A.y[0]*A.p[1] - A.z[0]*A.p[2];
  B->p[1] = -A.x[1]*A.p[0] - A.y[1]*A.p[1] - A.z[1]*A.p[2];
  B->p[2] = -A.x[2]*A.p[0] - A.y[2]*A.p[1] - A.z[2]*A.p[2];
}
//---------------------------------------------------------------------------
// Get a normal vector tangent to a segment endpoint (=1 for p1, =2 for p2)
// returns -1 if segment length or radius < tolerance, 0 on success
int GetTanVect(segment *s, fp p, int endpoint) {
fp q;

  if (s->type == LINE) {
    p[0] = s->p2[0] - s->p1[0];
    p[1] = s->p2[1] - s->p1[1];
    p[2] = s->p2[2] - s->p1[2];
    if (normalize(p, p) < tolerance) return(-1);
    else return(0);
  } else if (s->type == ARC) {
    if (endpoint == 1) {
      q[0] = s->p1[0] - s->c[0];
      q[1] = s->p1[1] - s->c[1];
      q[2] = s->p1[2] - s->c[2];
    } else {
      q[0] = s->p2[0] - s->c[0];
      q[1] = s->p2[1] - s->c[1];
      q[2] = s->p2[2] - s->c[2];
    }
    if (normalize(q, q) < tolerance) return(-1);
    cross(s->norm, q, p);
    return(0);
  }
  return(0);
}
//---------------------------------------------------------------------------
// Extract the reference frame for an arc
// Also fills in the radius and arclength

void GetArcFrame(segment *seg, frame *F) {
float q, theta;
fp p;

  if (seg->type != ARC) return;     // punt if not an arc

  F->p[0] = seg->c[0];              // origin is at the center
  F->p[1] = seg->c[1];
  F->p[2] = seg->c[2];
  F->x[0] = seg->p1[0] - seg->c[0]; // X vector points from center to P1
  F->x[1] = seg->p1[1] - seg->c[1];
  F->x[2] = seg->p1[2] - seg->c[2];
  seg->r = normalize(F->x, F->x);   // extract radius and normalize
  q = dot(F->x, seg->norm);         // make sure normal vector is perp. to X
  F->z[0] = seg->norm[0] - q*F->x[0];
  F->z[1] = seg->norm[1] - q*F->x[1];
  F->z[2] = seg->norm[2] - q*F->x[2];
  normalize(F->z, F->z);
  cross(F->z, F->x, F->y);

  p[0] =  seg->p2[0] - seg->c[0];   // get the arclength
  p[1] =  seg->p2[1] - seg->c[1];
  p[2] =  seg->p2[2] - seg->c[2];

  theta = atan2( dot(p,F->y), dot(p,F->x) );
  if (fabs(theta) < 0.001) theta = TWOPI - theta;
  seg->len = fabs(seg->r * theta);
  if (theta < 0) seg->len = (2*seg->r*PI - seg->len);
}
//---------------------------------------------------------------------------
// Returns a point p which lies on a line segment, and is a distance s from
// the start of the line segment

void GetLineSegPoint(segment *seg, float s, fp p) {
float r;

  r = (seg->len != 0. ?  s/seg->len : 0.);
  p[0] = seg->p1[0] + r*(seg->p2[0] - seg->p1[0]);
  p[1] = seg->p1[1] + r*(seg->p2[1] - seg->p1[1]);
  p[2] = seg->p1[2] + r*(seg->p2[2] - seg->p1[2]);
}
//---------------------------------------------------------------------------
// Gets the next point in the path.
// returns -1 if already at the end of the path
// returns 1 if the last point in the path
// returns 0 otherwise
int GetNextPathpoint(long int *xp, long int *yp, long int *zp) {
fp p;
int last_seg;

  if (at_end) return(-1);

// First check if decelerating to the endpoint

  if (vel*vel > 2*decl*(pathlen - arclen) ) {
    vel -= decl;
    if (vel<decl) vel = decl;  // use decl value as minimum velocity
  } else if (vel<maxvel) {     // check for acceleration to current maxvel
    vel += acc;
    if (vel>maxvel) vel = maxvel;
  } else if (vel>maxvel) {     // check for deceleration to current maxvel
    vel -= decl;
    if (vel<maxvel) vel = maxvel;
  }

  while (1) {                  // skip over a segment (or more) if necessary
    last_seg = sltail;
    if ( (stublen + vel) > seglist[sltail].len) {  // if past end of segment
      stublen -= seglist[sltail].len;              // subtract off the seg length
      inc_sltail();                                //inc. tail pointer to free up space
      if (sltail == slhead)
        { at_end = 1;                              //check for end of segment list
          break;
        }
      if (seglist[sltail].type == ARC)             // update arcframe if necessary
        GetArcFrame(  &(seglist[sltail]), &cur_arcframe );
    } else {
      stublen += vel;
      arclen  += vel;
      if (arclen > pathlen) at_end = 1;
      break;
    }
  }

  if (at_end) {                // return the final endpoint
    *xp = (long int)( (seglist[last_seg].p2[0] + xoff) * UTOCX );
    *yp = (long int)( (seglist[last_seg].p2[1] + yoff) * UTOCY );
    *zp = (long int)( (seglist[last_seg].p2[2] + zoff) * UTOCZ );
  } else {                     // find the point within the current segment
    if (seglist[sltail].type == LINE) {
      GetLineSegPoint( &(seglist[sltail]), stublen, p );
    } else if (seglist[sltail].type == ARC) {
      p[0] = (float) (seglist[sltail].r != 0. ? seglist[sltail].r * cos(stublen/seglist[sltail].r) : 0.);
      p[1] = (float) (seglist[sltail].r != 0. ? seglist[sltail].r * sin(stublen/seglist[sltail].r) : 0.);
      p[2] = 0;
      fvmult(&cur_arcframe, p, p);
    }
    *xp = (long int)( (p[0] + xoff) * UTOCX );
    *yp = (long int)( (p[1] + yoff) * UTOCY );
    *zp = (long int)( (p[2] + zoff) * UTOCZ );
  }
  return(at_end);
}
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
SetTangentTolerance                  <Ldcn.lib>

SYNTAX: void SetTangentTolerance (float theta);

PARAMETER1: <theta> - degree angle

KEYWORDS: CoordinatedMotion

DESCRIPTION: Set allowable angle (in degrees) between continuous path segments

RETURN VALUE: none
END DESCRIPTION **********************************************************/

// Theta = allowable angle (in degrees) between continuous path segments

/*** BeginHeader SetTangentTolerance */
     void SetTangentTolerance(float theta);
/*** EndHeader */

void SetTangentTolerance(float theta) {
  tan_tolerance = cos(theta*DTOR);
}
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
SetFeedrate                  <Ldcn.lib>

SYNTAX: void SetFeedrate (float fr);

PARAMETER1: <fr> - feedrate value

KEYWORDS: CoordinatedMotion

DESCRIPTION: Set feedrate in units per second

RETURN VALUE: none
END DESCRIPTION **********************************************************/

// Set feedrate in units per second

/*** BeginHeader SetFeedrate */
     void SetFeedrate(float fr);
/*** EndHeader */

void SetFeedrate(float fr) {
  switch (pathfreq) {                    // calculate velocity in units per tick
    case P_30HZ:  maxvel = fr / (1000./(64*0.512)); break;
    case P_60HZ:  maxvel = fr / (1000./(32*0.512)); break;
    case P_120HZ: maxvel = fr / (1000./(16*0.512)); break;
    default:      maxvel = fr / (1000./(64*0.512));
  }
}
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
SetPathParams                 <Ldcn.lib>

SYNTAX: int SetPathParams (int freq, int nbuf, int xaxis, int yaxis, int zaxis,
                           int groupaddr,float xscale, float yscale, float zscale,
                           float accel, float decel);

PARAMETER1:  <freq>      - set using defined constants P_30HZ, P_60HZ or P_120HZ
PARAMETER2:  <nbuf>      - number of points to store in the path point buffer (max 87)
PARAMETER3:  <xaxis>     - individual module addresses for the X axes
PARAMETER4:  <yaxis>     - individual module addresses for the Y axes
PARAMETER5:  <zaxis>     - individual module addresses for the Z axes
PARAMETER6:  <groupaddr> - group address
PARAMETER7:  <xscale>    - scale factor for the X axes
PARAMETER8:  <yscale>    - scale factor for the Y axes
PARAMETER9:  <zscale>    - scale factor for the Z axes
PARAMETER10: <accel>     - acceleration in units per tick
PARAMETER11: <decel>     - deceleration in units per tick

KEYWORDS: CoordinatedMotion

DESCRIPTION: Initialize various parameters for this path generation module
             Returns : -1 if Status items are not set properly
                       -2 if scale facotrs are zero
                       -3 if ServoSetFastPath returned False
                        0 if OK

RETURN VALUE:  (-3, -2, -1 or 0)
END DESCRIPTION **********************************************************/

// Initialize various parameters for this path generation module
// Returns -1 if Status items are not set properly,
//         -2 if scale facotrs are zero

/*** BeginHeader SetPathParams */
     int SetPathParams(int freq, int nbuf, int xaxis, int yaxis, int zaxis, int groupaddr,
                       float xscale, float yscale, float zscale, float accel, float decel);
/*** EndHeader */

int SetPathParams(int freq, int nbuf,
                  int xaxis, int yaxis, int zaxis, int groupaddr,
                  float xscale, float yscale, float zscale,
                  float accel, float decel) {
byte statitems;
bool OK;
byte sr;
float ACCCOEF, AccCoef;
long dcl;
float real_freq;

  segchain _GLOBAL_INIT {
    ACCCOEF = 1000000000000.0/17179869184.; // 10^12/2^34
    tan_tolerance = TAN_3DEGREE;
    pathfreq = P_30HZ;
    x = 1;
    y = 2;
    z = 3;
    group = 0xFF;
    IsPathInitialized = false;
    path_net_num = -1;
  }

  pathfreq = freq;        // set to 30 or 60 hz
  bufsize = nbuf;         // max num points to store in the PIC-SERVO buffer
  //axes addresses
  x = (byte) xaxis;
  y = (byte) yaxis;
  z = (byte) zaxis;
  if ((x == 0) || (z && !(y))) return -1;

  sr = mod[x].kind.servo.gain.sr;
  if (sr) {
     AccCoef = ACCCOEF / sr;
     dcl = (long) fabs((decel * xscale ) / AccCoef);
     LdcnReadStatus(x, SEND_POS);
     ServoLoadTraj(x, LOAD_POS | LOAD_VEL | LOAD_ACC | START_NOW | ENABLE_SERVO, ServoGetPos(x), dcl, dcl, 0);
  }

  if (y) {
     sr = mod[y].kind.servo.gain.sr;
     if (sr) {
       AccCoef = ACCCOEF / sr;
       dcl = (long) fabs((decel * xscale ) / AccCoef);
       LdcnReadStatus(y, SEND_POS);
       ServoLoadTraj(y, LOAD_POS | LOAD_VEL | LOAD_ACC | START_NOW | ENABLE_SERVO, ServoGetPos(y), dcl, dcl, 0);
     }
  }

  if (z) {
     sr = mod[z].kind.servo.gain.sr;
     if (sr) {
       AccCoef = ACCCOEF / sr;
       dcl = (long) fabs((decel * xscale ) / AccCoef);
       LdcnReadStatus(z, SEND_POS);
       ServoLoadTraj(z, LOAD_POS | LOAD_VEL | LOAD_ACC | START_NOW | ENABLE_SERVO, ServoGetPos(z), dcl, dcl, 0);
     }
  }

  group = (byte)groupaddr;

  LdcnSetGroupAddr(x, group, true);
  if (y) LdcnSetGroupAddr(y, group, false);
  if (z) LdcnSetGroupAddr(z, group, false);

  ServoStopMotor(x, ServoGetStopCtrl(x) | ADV_MODE);
  if (y) ServoStopMotor(y, ServoGetStopCtrl(y) | ADV_MODE);
  if (z) ServoStopMotor(z, ServoGetStopCtrl(z) | ADV_MODE);


  if (freq == P_120HZ) {  // set fast path mode if using 120 Hz path
    OK = ServoSetFastPath(x, true);
    if (y) OK = (OK && ServoSetFastPath(y, true));
    if (z) OK = (OK && ServoSetFastPath(z, true));
  } else {                // otherwise, use slow mode
    OK = ServoSetFastPath(x, false);
    if (y) OK = (OK && ServoSetFastPath(y, false));
    if (z) OK = (OK && ServoSetFastPath(z, false));
  }
  if (!OK) return -3;

  if (fabs(xscale) == 0.0) return(-2);
  if ( y && (fabs(yscale) == 0.0) ) return(-2);
  if ( z && (fabs(zscale) == 0.0) ) return(-2);

  UTOCX = xscale;         // Units To X counts
  UTOCY = yscale;
  UTOCZ = zscale;

// Set the tolerance equivalent to 40 counts of the lowest resolution axis
  tolerance = fabs(40.0/xscale);
  if (y)
    if (tolerance < fabs(40.0/yscale)) tolerance = fabs(40.0/yscale);
  if (z)
    if (tolerance < fabs(40.0/zscale)) tolerance = fabs(40.0/zscale);

//  switch (pathfreq) {     // calculate acceleration in units per tick^2
//    case P_30HZ:  acc  = accel/30.0/30.0;
//                  decl = decel/30.0/30.0;
//                  break;
//    case P_60HZ:  acc  = accel/60.0/60.0;
//                  decl = decel/60.0/60.0;
//                  break;
//    case P_120HZ: acc  = accel/120.0/120.0;
//                  decl = decel/120.0/120.0;
//                  break;
//    default:      acc  = accel/30.0/30.0;
//                  decl = decel/30.0/30.0;
//  }


  switch (pathfreq) {    //calculate acceleration in units per tick^2
    case P_30HZ : real_freq = (1000./(64*0.512)); break;
    case P_60HZ : real_freq = (1000./(32*0.512)); break;
    case P_120HZ: real_freq = (1000./(16*0.512)); break;
    default     : real_freq = (1000./(64*0.512)); break;
  }

  acc  = accel/real_freq/real_freq;
  decl = decel/real_freq/real_freq;

// Check that the required status data will be returned with each command:
  statitems = SEND_POS | SEND_NPOINTS | SEND_PERROR | SEND_AUX;

  LdcnDefineStatus(x, LdcnGetStatItems(x) | statitems);
  if (y) LdcnDefineStatus(y, LdcnGetStatItems(y) | statitems);
  if (z) LdcnDefineStatus(z, LdcnGetStatItems(z) | statitems);

  path_net_num = net_num;
  return(0);
}
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
ClearSegList                  <Ldcn.lib>

SYNTAX: void ClearSegList (float xi, float yi, float zi);

PARAMETER1: <xi> - x starting value
PARAMETER2: <yi> - y starting value
PARAMETER3: <zi> - z starting value

KEYWORDS: CoordinatedMotion

DESCRIPTION: Clears the internal segment list and sets the starting
             point for a new set of segments. The new starting point
             (x, y, z) should be in whatever units you choose to use
             for the scale parameters set with SetPathParams ().

RETURN VALUE:  none
END DESCRIPTION **********************************************************/

// Clear the current segment list and initialize the starting point

/*** BeginHeader ClearSegList */
     void ClearSegList(float xi, float yi, float zi);
/*** EndHeader */

void ClearSegList(float xi, float yi, float zi) {

  seg_is_added = 0;
  slhead = 0;
  sltail = 0;
  pathlen = 0;
  seglist[0].p1[0] = xi;
  seglist[0].p1[1] = yi;
  seglist[0].p1[2] = zi;
  IsPathInitialized = false;
}
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
AddLineSeg                 <Ldcn.lib>

SYNTAX: int AddLineSeg (float x, float y, float z);

PARAMETER1: <x> - x endpoint of the line
PARAMETER2: <y> - y endpoint of the line
PARAMETER3: <z> - z endpoint of the line

KEYWORDS: CoordinatedMotion

DESCRIPTION: Adds a line segment to the internal segment list.

RETURN VALUE: index of the segment in the segment list if OK
              -1 if segment is not tangent
              -2 if segment list is full
END DESCRIPTION **********************************************************/

// Add a line segment to the segment list
// Returns: position in segment list if OK
//          -1 if segment is not tangent
//          -2 if segment list is full
// Function assumes the normal vector of any previous arc segment is accurate

/*** BeginHeader AddLineSeg */
     int AddLineSeg(float x, float y, float z);
/*** EndHeader */

int AddLineSeg(float x, float y, float z) {
fp pn, qn;

  inc_slhead();             // test increment the head pointer to check for room
  if (slhead == sltail)
    {
    dec_slhead();
    return(-2);
    }
  dec_slhead();  //  point back to the current position

  seglist[slhead].type = LINE;

  seglist[slhead].p2[0] = x;
  seglist[slhead].p2[1] = y;
  seglist[slhead].p2[2] = z;

  if (seg_is_added) {          // match start point to end point of prev segment
    seglist[slhead].p1[0] = seglist[prev_seg()].p2[0];
    seglist[slhead].p1[1] = seglist[prev_seg()].p2[1];
    seglist[slhead].p1[2] = seglist[prev_seg()].p2[2];
  }

//  Calculate normal vector and length for this segment
  pn[0] = x - seglist[slhead].p1[0];
  pn[1] = y - seglist[slhead].p1[1];
  pn[2] = z - seglist[slhead].p1[2];
  seglist[slhead].len = normalize(pn, pn);

// Check tangency with prev. segment for segments > tolerance:
  if ( (seglist[slhead].len > tolerance) && seg_is_added )
    if ( GetTanVect( &(seglist[prev_seg()]), qn, 2) == 0 )
      if (dot(pn,qn) < tan_tolerance) return(-1);

  pathlen += seglist[slhead].len;      //  increment the overall path length

  inc_slhead();
  seg_is_added = 1;
  return(prev_seg());
}
//---------------------------------------------------------------------------

// Add an arc segment to the segment list
// Returns: position in segment list if OK
//          -1 if segment is not tangent
//          -2 if segment list is full
//          -3 if arc data invalid
// (Invalid arc data - zero len. normal, radius < tolerance, normal not perp.)
// Function assumes the normal vector of any previous arc segment is accurate

/* START FUNCTION DESCRIPTION ********************************************
AddArcSeg                 <Ldcn.lib>

SYNTAX: int AddArcSeg (float x, float y, float z, float cx, float cy, float cz,
                           float nx, float ny, float nz);
PARAMETER1: <x>  - x end point value
PARAMETER2: <y>  - y end point value
PARAMETER3: <z>  - z end point value
PARAMETER4: <cx> - x center poin value
PARAMETER5: <cy> - y center poin value
PARAMETER6: <cz> - z center poin value
PARAMETER7: <nx> - x vector normal value
PARAMETER8: <ny> - y vector normal value
PARAMETER9: <nz> - z vector normal value

KEYWORDS: CoordinatedMotion

DESCRIPTION:Adds an arc segment to the internal segment list. Coordinates (x, y,  z)
            are  the  endpoint  of  the  arc,  coordinates (cx,cy,cz) are the center
            point of  the arc,  and coordinates  (nx,ny,nz) form  a vector normal to
            the plane of the  arc. The direction of  the normal vector (positive  or
            negative)  dictates  the  direction  of  the  arc, moving from the start
            point  to  the  endpoint  in  a  right-handed  sense. The end and center
            points coordinates  should be  relative to  the origin,  and in whatever
            units  you   choose  to   use  for   the  scale   parameters  set   with
            SetPathParams().

RETURN VALUE: Index of the segment in the segment list if OK, -3 if arc data is invalid,
           -2 if segment list is full, -1 if segment is not tangent
           (Invalid arc data - zero length, normal or radius < tolerance, normal not perp.)
            Function assumes the normal vector of any previous arc segment is accurate.
END DESCRIPTION **********************************************************/

/*** BeginHeader AddArcSeg */
     int AddArcSeg( float x, float y, float z, float cx, float cy, float cz, float nx, float ny, float nz);
/*** EndHeader */

int AddArcSeg( float x, float y, float z,      // end point
               float cx, float cy, float cz,   // center point
               float nx, float ny, float nz) { // normal
fp pn, qn;
frame F;

  inc_slhead();            //  test increment the head pointer to check for room
  if (slhead == sltail)
    {
    dec_slhead();
    return(-2);
    }
  dec_slhead();            //  point back to the current position

  seglist[slhead].type = ARC;

  seglist[slhead].p2[0] = x;
  seglist[slhead].p2[1] = y;
  seglist[slhead].p2[2] = z;
  seglist[slhead].c[0] = cx;
  seglist[slhead].c[1] = cy;
  seglist[slhead].c[2] = cz;
  seglist[slhead].norm[0] = nx;
  seglist[slhead].norm[1] = ny;
  seglist[slhead].norm[2] = nz;

  if (seg_is_added) {      //  match start point to end point of prev segment
    seglist[slhead].p1[0] = seglist[prev_seg()].p2[0];
    seglist[slhead].p1[1] = seglist[prev_seg()].p2[1];
    seglist[slhead].p1[2] = seglist[prev_seg()].p2[2];
  }

// Normalize n and punt if too small
  if ( normalize(seglist[slhead].norm, seglist[slhead].norm) < 0.5 )
    return(-3);

// Find radius to p2, and punt if too small
  pn[0] = x - cx;
  pn[1] = y - cy;
  pn[2] = z - cz;
  seglist[slhead].r = normalize(pn, pn);
  if ( seglist[slhead].r < tolerance) return(-3);

// Check if normal is perp to c->p2 vector and punt if not
  if ( fabs(dot(seglist[slhead].norm, pn)) > 0.001 ) return(-3);

// Find radius to p1, and punt if not equal to radius to p2
  pn[0] = seglist[slhead].p1[0] - cx;
  pn[1] = seglist[slhead].p1[1] - cy;
  pn[2] = seglist[slhead].p1[2] - cz;
  if ( fabs(seglist[slhead].r - normalize(pn, pn)) > tolerance) return(-3);

// Check if normal is perp to c->p2 vector and punt if not
  if ( fabs(dot(seglist[slhead].norm, pn)) > 0.001 ) return(-3);

// Check for tangency with prev segment
  if (seg_is_added) {
    GetTanVect( &(seglist[slhead]), pn, 1);                //get current tangent
    if ( GetTanVect( &(seglist[prev_seg()]), qn, 2) == 0 ) // get prev tangent
      if (dot(pn,qn) < tan_tolerance) return(-1);
  }

  GetArcFrame(&(seglist[slhead]), &F);      //  fills in segment length

  pathlen += seglist[slhead].len;           // increment the overall path length

  inc_slhead();
  seg_is_added = 1;
  return(prev_seg());
}
//---------------------------------------------------------------------------

// Initializes the coordinated path after all of the segments have been added.
// This function should be called just before the application starts calling
// the function AddPathPoints().
// Returns the overall path length for all of the segments.
// Returns 0.0 on communications error

/* START FUNCTION DESCRIPTION ********************************************
InitPath                   <Ldcn.lib>

SYNTAX: float InitPath ();

KEYWORDS: CoordinatedMotion

DESCRIPTION: Initializes the  coordinated path  after all  of the  segments have been
             added.  This  function  should  be  called  just  before the application
             starts calling the function  AddPathPoints (). Returns the  overall path
             length for all of the segments. Returns 0.0 on communications error

RETURN VALUE: Overall path length for all segments, 0 if found any error
END DESCRIPTION **********************************************************/

/*** BeginHeader InitPath */
     float InitPath();
/*** EndHeader */

float InitPath() {

  curppoint = 0;
  arclen    = 0.0;
  stublen   = 0.0;
  vel       = 0.0;
  at_end    = 0;

  if (seglist[0].type == ARC) GetArcFrame( &(seglist[0]), &cur_arcframe );

// make sure we exit path mode first
  if        (!ServoStopMotor(x, ServoGetStopCtrl(x) | (byte)SRV_ENABLE_AMP)) return(0.0);
  if (y) if (!ServoStopMotor(y, ServoGetStopCtrl(y) | (byte)SRV_ENABLE_AMP)) return(0.0);
  if (z) if (!ServoStopMotor(z, ServoGetStopCtrl(z) | (byte)SRV_ENABLE_AMP)) return(0.0);

  ServoInitPath(x);     // set the beginning of the path to the current position
  if (y) ServoInitPath(y);
  if (z) ServoInitPath(z);

  xoff = x ? (float)( mod[x].kind.servo.last_ppoint) / UTOCX - seglist[sltail].p1[0] : 0;
  yoff = y ? (float)( mod[y].kind.servo.last_ppoint) / UTOCY - seglist[sltail].p1[1] : 0;
  zoff = z ? (float)( mod[z].kind.servo.last_ppoint) / UTOCZ - seglist[sltail].p1[2] : 0;

  return(pathlen);
}
//---------------------------------------------------------------------------

// Adds points to path buffer - should be called at regular intervals which
// are shorter than the buffer time (bufsize/pathfreq).
//
// Returns: -1     if path download is done
//          curseg if in middle  of the path
//          -2     if communication error
//          -3

/* START FUNCTION DESCRIPTION ********************************************
AddPathPoints                 <Ldcn.lib>

SYNTAX: int AddPathPoints ();

KEYWORDS: CoordinatedMotion

DESCRIPTION: Adds path points  to the path  point buffers, and  begins path execution
             automatically after nbuf points have  been added. If the path  is longer
             that can be  held in the  buffers, additional calls  to AddPathPoints ()
             should be  made frequently  enough to  make sure  the buffers  are never
             emptied prematurely.
RETURN VALUE: current segment or
              0 if the path is not complete (ie, more points need to be added)
             -1 if all path points for the current segment list have been downloaded
             -2 on a communications error
END DESCRIPTION **********************************************************/

/*** BeginHeader AddPathPoints */
     int AddPathPoints();
/*** EndHeader */

int AddPathPoints() {
long int xp[7], yp[7], zp[7];        // set of up to 7 pathpoints
int pcount, res;

  if (path_net_num != net_num) { printf( "SET CORRECT NET NUMBER!!!"); return -4; }
  
  if (!IsPathInitialized) { InitPath(); IsPathInitialized = true; }

// VEL = MAXVEL = 0.0 defines a feedhold condition
// Setting MAXVEL to a non-zero value will resume path execution
  if (maxvel==0.0 && vel == 0.0) return(sltail);

  while (!at_end) {                //  GetNextPathpoint() sets the global at_end
    if (!LdcnNoOp(x)) return(-2);  //  read num points from X

// punt when PIC-SERVO buffer is full
    if ((ServoGetNPoints(x)>bufsize) || (ServoGetNPoints(x)>87)) {
      if (y) if (!LdcnNoOp(y)) return(-2);  //make sure data is updated even if points are not added
      if (z) if (!LdcnNoOp(z)) return(-2);
      break;
    }

    for (pcount=0; pcount < 7; pcount++) {   //  get upto 7 new points
      res = GetNextPathpoint( xp+pcount, yp+pcount, zp+pcount);
      if (res) break;
    }
    if ((pcount < 7) && (res > 0)) pcount++;

    if        (!ServoAddPathPoints(x, pcount, xp, pathfreq != P_30HZ)) return(-3);
    if (y) if (!ServoAddPathPoints(y, pcount, yp, pathfreq != P_30HZ)) return(-3);
    if (z) if (!ServoAddPathPoints(z, pcount, zp, pathfreq != P_30HZ)) return(-3);
  }

  if ( !(ServoGetAux(x) & PATH_MODE))      // start path mode when buffer full
    if (!ServoStartPathMode(group)) return(-2);

  if (at_end) return(-1);
  return(sltail);
}
//---------------------------------------------------------------------------

/* START FUNCTION DESCRIPTION ********************************************
SegmentsInBuffer                 <Ldcn.lib>

SYNTAX: int SegmentsInBuffer ();

KEYWORDS: CoordinatedMotion

DESCRIPTION: Returned number of segments in buffer

RETURN VALUE: number of segments in buffer
END DESCRIPTION **********************************************************/

/*** BeginHeader SegmentsInBuffer */
     int SegmentsInBuffer();
/*** EndHeader */

int SegmentsInBuffer() {

  if (slhead == sltail) return 0;
  if (slhead >  sltail) return (slhead - sltail);
  return MAXSEG - (sltail - slhead) + 1;
}
//---------------------------------------------------------------------------
